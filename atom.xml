<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>eli&#39;s murmur</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mur.elii.io/"/>
  <updated>2018-06-06T07:37:47.000Z</updated>
  <id>https://mur.elii.io/</id>
  
  <author>
    <name>eli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>夢想動畫Houdini工具套件說明</title>
    <link href="https://mur.elii.io/ms-houdini-workpack/"/>
    <id>https://mur.elii.io/ms-houdini-workpack/</id>
    <published>2018-04-24T07:06:39.000Z</published>
    <updated>2018-06-06T07:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>安裝方法 (二選一)：<br>A - 將 <code>Q:\resource\houdini.env</code> 複製到 <code>C:\Users\使用者名稱\Documents\houdini16.5</code> 並覆蓋<br>B - 直接打開 <code>C:\Users\使用者名稱\Documents\houdini16.5\houdini.env</code><br>並在最後加上兩行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HOUDINI_OTLSCAN_PATH=&quot;Q:/resource/houdini;@/otls&quot;</span><br><span class="line">HOUDINI_MENU_PATH=&quot;Q:/resource/houdini;@/&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用方式：<br>指令在選單列<code>MoonShine</code>底下，節點在右鍵(Tab)的<code>Elisha&#39;s Tools</code>底下</p></li></ul><a id="more"></a><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p><img src="https://i.imgur.com/QeFB6w2.png" alt=""></p><ul><li><p>Link Bound<br>將模擬的外框<code>size</code>跟<code>pivot</code>連結到指定的物件</p></li><li><p>Link Parm<br>連結節點大小或中心給參數</p></li><li><p>Add Vex Function<br>對<code>Attribute Wrangle</code>頂部增加常用公式<br>– 兩向量夾角 : 兩個向量的角度<br>– 動畫控制 : 基礎的程序動態控制公式</p></li><li><p>Create Rop From Cache<br>將cache包成rop給deadline放模擬</p></li><li><p>Add Seperate EXR From Rop<br>在rop下增加EXR拆層</p></li><li><p>Export Transform Info<br>匯出位置資訊的文字檔案</p></li><li><p>Export Material Info<br>匯出材質資訊的文字檔案</p></li><li><p>Help<br>開啟套件說明網頁</p></li></ul><h1 id="節點"><a href="#節點" class="headerlink" title="節點"></a>節點</h1><h2 id="Animated-Bound-動態外框"><a href="#Animated-Bound-動態外框" class="headerlink" title="Animated Bound / 動態外框"></a>Animated Bound / 動態外框</h2><p><img src="https://i.imgur.com/bPYWp88.png" alt=""></p><blockquote><p><strong>動態範圍的bounding box</strong></p></blockquote><p>指定時間範圍取出最大的bounding範圍</p><ul><li>Frame : 時間範圍</li><li>Calculate : 按下開始計算</li><li>Lower Padding : 同bound參數</li><li>Upper Padding : 同bound參數</li></ul><h2 id="Attribute-to-Material-依屬性創建材質"><a href="#Attribute-to-Material-依屬性創建材質" class="headerlink" title="Attribute to Material / 依屬性創建材質"></a>Attribute to Material / 依屬性創建材質</h2><p><img src="https://i.imgur.com/SOcuWyr.png" alt=""></p><blockquote><p><strong>根據屬性創建相對應材質</strong></p></blockquote><p>主要是給FBX輸出用，常搭配<a href="#group-to-attribute--%E7%BE%A4%E7%B5%84%E8%BD%89%E6%8F%9B%E6%88%90%E5%B1%AC%E6%80%A7">Group to Attribute</a>做使用</p><ul><li>Attribute Name : 對應的屬性，右邊箭頭下拉有目前屬性方便選取</li><li>Delete Attribute : 對應後刪除屬性</li><li>Refresh : 強制更新材質</li></ul><h2 id="Batch-Schedule-佇列排程執行"><a href="#Batch-Schedule-佇列排程執行" class="headerlink" title="Batch Schedule / 佇列排程執行"></a>Batch Schedule / 佇列排程執行</h2><p><img src="https://i.imgur.com/D0bpmDm.png" alt=""></p><blockquote><p><strong>將模擬或算圖排程執行並在完成時獲得通知與經過時間</strong></p></blockquote><ul><li>Node : 將要排程的節點拖曳到此欄位</li><li>Add to List : 按此按鈕加入排程佇列</li><li>Relative : 用相對路徑的方式加入節點，以維持架構</li><li>Batch List : 排程佇列，前面勾勾可以略過排程，也可在此手動添加/更改節點</li><li>Email : 可以勾選在排程完成後寄信通知，如果寄信成功，此欄位的電子信箱會自動儲存在電腦裡</li></ul><h2 id="Camera-Cone-攝影機視角範圍生成"><a href="#Camera-Cone-攝影機視角範圍生成" class="headerlink" title="Camera Cone / 攝影機視角範圍生成"></a>Camera Cone / 攝影機視角範圍生成</h2><p><img src="https://i.imgur.com/LKy0yIj.png" alt=""></p><blockquote><p><strong>依照攝影機視角產生六面體模型</strong></p></blockquote><ul><li>Camera : 選擇攝影機</li><li>Near : 攝影機起始的Z值</li><li>Far : 攝影機終點的Z值</li><li>X Offset : 攝影機寬度的微調</li><li>Y Offset : 攝影機高度的微調</li></ul><h2 id="Compute-Velocity-速度計算"><a href="#Compute-Velocity-速度計算" class="headerlink" title="Compute Velocity / 速度計算"></a>Compute Velocity / 速度計算</h2><p><img src="https://i.imgur.com/UWxpuVR.png" alt=""></p><blockquote><p><strong>取代trail的快速運算</strong></p></blockquote><ul><li>Match Attribute : 屬性配對，通常是id或name</li></ul><h2 id="Crop-by-Camera-攝影機裁切"><a href="#Crop-by-Camera-攝影機裁切" class="headerlink" title="Crop by Camera / 攝影機裁切"></a>Crop by Camera / 攝影機裁切</h2><p><img src="https://i.imgur.com/pcoYPqV.png" alt=""></p><blockquote><p><strong>依照攝影機視野去做裁切</strong></p></blockquote><ul><li>Camera : 指定要裁切的攝影機</li><li>Frame Offset : X與Y軸框架的微調</li><li>Crop Z / Z Offset : Z軸的裁切</li></ul><h2 id="Duplicate-Wires-線條複製"><a href="#Duplicate-Wires-線條複製" class="headerlink" title="Duplicate Wires / 線條複製"></a>Duplicate Wires / 線條複製</h2><p><img src="https://i.imgur.com/k53tp2p.png" alt=""></p><blockquote><p><strong>將線條以自身為中心，複製多份</strong></p></blockquote><ul><li>Radius : 複製線條的半徑</li><li>Amount : 線條數量</li></ul><h2 id="Edge-Group-to-Curve-邊線群組轉換線條"><a href="#Edge-Group-to-Curve-邊線群組轉換線條" class="headerlink" title="Edge Group to Curve / 邊線群組轉換線條"></a>Edge Group to Curve / 邊線群組轉換線條</h2><p><img src="https://i.imgur.com/YmBl0nD.png" alt=""></p><blockquote><p><strong>將物件的Edge群組取出成線條</strong></p></blockquote><ul><li>Group : Edge群組選擇，右邊箭頭可下拉快速選取</li><li>Fuse Vertices : 連結所有線條</li></ul><h2 id="Export-Pack-to-FBX-Pack物件輸出FBX"><a href="#Export-Pack-to-FBX-Pack物件輸出FBX" class="headerlink" title="Export Pack to FBX / Pack物件輸出FBX"></a>Export Pack to FBX / Pack物件輸出FBX</h2><p><img src="https://i.imgur.com/6kRO708.png" alt=""></p><blockquote><p><strong>將Pack物件動態分成個體輸出FBX</strong></p></blockquote><p>主要是用在碎裂特效輸出到3ds Max或遊戲軟體，在面數與物件不多的情況之下，對空間與效能節省許多，可調性也比較高。</p><ul><li>Output File : 輸出FBX的路徑</li><li>Start/End : 開始與結束影格</li><li>Scene Scale : 場景大小</li></ul><h2 id="Export-Point-Cache-輸出Point-Cache"><a href="#Export-Point-Cache-輸出Point-Cache" class="headerlink" title="Export Point Cache / 輸出Point Cache"></a>Export Point Cache / 輸出Point Cache</h2><p><img src="https://i.imgur.com/pVQGHyw.png" alt=""></p><blockquote><p><strong>輸出給MAX和MAYA讀取的FBX與PC2檔，注意要三角面</strong></p></blockquote><ul><li>Export : 輸出FBX和PC2</li><li>Export Cache Only : 只輸出PC2</li><li>Start/End : 輸出影格範圍</li><li>Export Path : 輸出路徑</li><li>File Name : 檔案名稱</li></ul><h2 id="Export-to-AE-將物件跟攝影機輸出到AE"><a href="#Export-to-AE-將物件跟攝影機輸出到AE" class="headerlink" title="Export to AE / 將物件跟攝影機輸出到AE"></a>Export to AE / 將物件跟攝影機輸出到AE</h2><p><img src="https://i.imgur.com/ouBG1Nq.png" alt=""></p><blockquote><p><strong>產生可讓AE讀取物件位置跟攝影機動態的檔案</strong></p></blockquote><p>物件部分目前只可讀最外層的obj，之後會想改良成point位置會比較方便</p><h2 id="Extract-Matrix-分析位移資訊"><a href="#Extract-Matrix-分析位移資訊" class="headerlink" title="Extract Matrix / 分析位移資訊"></a>Extract Matrix / 分析位移資訊</h2><p><img src="https://i.imgur.com/vV7dghn.png" alt=""></p><blockquote><p><strong>將只有頂點動態的物件分析出Matrix資訊</strong></p></blockquote><ul><li>Cache Trasnsform Data : 將分析資訊儲存cache</li><li>Geometry File : cache儲存位置</li><li>Group Similar Transform : 將類似的位移物件群組起來</li><li>Visualize Groups : 顯示不同群組</li><li>Grp Threshold : 群組位移資訊的相似度</li><li>Frame : 群組判斷的格數</li></ul><h2 id="Fit-Zero-One-Attribute-映射屬性到01"><a href="#Fit-Zero-One-Attribute-映射屬性到01" class="headerlink" title="Fit Zero One Attribute / 映射屬性到01"></a>Fit Zero One Attribute / 映射屬性到01</h2><p><img src="https://i.imgur.com/4LUcIHr.png" alt=""></p><blockquote><p><strong>將屬性延展或壓縮，對應到0~1之間</strong></p></blockquote><ul><li>Attribute Type : 屬性類別</li><li>Fit Attribute : 屬性名稱</li><li>Create New Name : 重新命名新映射的屬性名稱(不沿用原名稱)</li><li>New Attribute Name : 新屬性名稱</li></ul><h2 id="Grid-Points-產生格點"><a href="#Grid-Points-產生格點" class="headerlink" title="Grid Points / 產生格點"></a>Grid Points / 產生格點</h2><p><img src="https://i.imgur.com/GbUElEQ.png" alt=""></p><blockquote><p><strong>對物體產生等距格點</strong></p></blockquote><ul><li>Length : 點與點之間的距離</li><li>Expand : 範圍的延伸或縮減</li></ul><h2 id="Group-to-Attribute-群組轉換成屬性"><a href="#Group-to-Attribute-群組轉換成屬性" class="headerlink" title="Group to Attribute / 群組轉換成屬性"></a>Group to Attribute / 群組轉換成屬性</h2><p><img src="https://i.imgur.com/SEAs3ba.png" alt=""></p><blockquote><p><strong>將群組變成字串屬性，群組名稱為屬性值</strong></p></blockquote><ul><li>Attribute Name : 轉換成的屬性名稱，右邊下拉箭頭有預設項目</li><li>Delete Groups : 轉換後刪除群組</li></ul><h2 id="Keep-Biggest-Part-保留最大區塊"><a href="#Keep-Biggest-Part-保留最大區塊" class="headerlink" title="Keep Biggest Part / 保留最大區塊"></a>Keep Biggest Part / 保留最大區塊</h2><p><img src="https://i.imgur.com/hZ5Rppz.png" alt=""></p><blockquote><p><strong>利用connectivity區分部件，並只保留最大體積區塊</strong></p></blockquote><h2 id="Material-from-3dsMax-繼承3dsMax材質"><a href="#Material-from-3dsMax-繼承3dsMax材質" class="headerlink" title="Material from 3dsMax / 繼承3dsMax材質"></a>Material from 3dsMax / 繼承3dsMax材質</h2><p><img src="https://i.imgur.com/6INO0OT.png" alt=""></p><blockquote><p><strong>取得max場景物件的材質資訊，並重新上回在houdini的alembic，以及最後到max的VrayProxy材質重新對應回去</strong></p><ul><li>Get Max Script : 開啟含有maxscript的資料夾，裏頭有兩個script</li></ul></blockquote><pre><code><pre><code class="hljs undefined">-- `A_getMaterial` : 在3dsMax裡選取要取得材質資訊的物件並執行，會將資訊複製到剪貼簿，然後再貼到Material Data的欄位上-- `B_applyMaterial` : 在3dsMax匯入VrayProxy後，選取並執行，將材質對應回去</code></pre></code></pre><ul><li>Material Data : 將<code>A_getMaterial</code>執行產生的資訊貼在此處</li><li>Attribute Name : 材質資料的屬性名稱</li></ul><h2 id="Merge-to-Class-合併並分類"><a href="#Merge-to-Class-合併並分類" class="headerlink" title="Merge to Class / 合併並分類"></a>Merge to Class / 合併並分類</h2><p><img src="https://i.imgur.com/km73Qjv.png" alt=""></p><blockquote><p><strong>將輸入的節點merge並依輸入順序設定class屬性</strong></p></blockquote><h2 id="Packed-Disk-Edit-Packed-Disk編輯"><a href="#Packed-Disk-Edit-Packed-Disk編輯" class="headerlink" title="Packed Disk Edit / Packed Disk編輯"></a>Packed Disk Edit / Packed Disk編輯</h2><p><img src="https://i.imgur.com/EPP7jO2.png" alt=""></p><blockquote><p><strong>改變Packed Disk路徑或格數，修正原有節點瑕疵</strong></p><ul><li>Rename Path : 重新命名路徑<br>– Group : 群組過濾<br>– Source Pattern : 原有名稱要取代的部分<br>– Destination Pattern : 取代後的新名稱</li><li>Frame index : 更改影格<br>– Sequence Index : 影格數字<br>– By Attribute : 用primitive的屬性來更改影格數字</li><li>Wrap Type : 影格範圍到盡頭的行為<br>– clamp : 停留在最後一格<br>– cycle : 重複播放<br>– strict : 空白物件</li></ul></blockquote><h2 id="Patch-Particles-粒子填充"><a href="#Patch-Particles-粒子填充" class="headerlink" title="Patch Particles / 粒子填充"></a>Patch Particles / 粒子填充</h2><p><img src="https://i.imgur.com/ce53PJt.png" alt=""></p><blockquote><p><strong>將每格粒子數量補足成最後的數量，主要用在破碎碎粒可以做成頂點動畫</strong></p></blockquote><ul><li>Input0 : 粒子動畫</li><li>Input1 : 最後一格的粒子</li></ul><h2 id="Quick-Bound-Clip-快速方塊切割"><a href="#Quick-Bound-Clip-快速方塊切割" class="headerlink" title="Quick Bound Clip / 快速方塊切割"></a>Quick Bound Clip / 快速方塊切割</h2><p><img src="https://i.imgur.com/2LZ3L2N.png" alt=""></p><blockquote><p><strong>給予一個方塊(可旋轉)，將模型快速裁切在BOX裡面</strong></p></blockquote><h2 id="Rotate-Prims-剝皮"><a href="#Rotate-Prims-剝皮" class="headerlink" title="Rotate Prims / 剝皮"></a>Rotate Prims / 剝皮</h2><p><img src="https://i.imgur.com/BYQB1yA.png" alt=""></p><blockquote><p><strong>將Primitive針對參考點去捲動，類似剝皮的效果</strong></p></blockquote><ul><li>Time : 動畫時間點</li><li>Range : 每個轉換過程佔據整體時間的比例</li><li>Flip Direction : 相反旋轉方向</li><li>Amount : 旋轉的強度</li><li>(Rotation) Progress Curve : 旋轉動畫的過程曲線</li><li>(Shrink) Progress Curve : 縮小動畫的過程曲線</li><li>Remove Empty Primitives : 移除縮到看不見的面</li><li>Remove Computed Attributes : 移除中途計算的屬性</li></ul><h2 id="Seperate-物件分類"><a href="#Seperate-物件分類" class="headerlink" title="Seperate / 物件分類"></a>Seperate / 物件分類</h2><p><img src="https://i.imgur.com/EyMS93W.png" alt=""></p><blockquote><p><strong>用選取方式將物件拆解分成不同部位</strong></p></blockquote><ul><li>Create Node to Parts : 根據群組產生各自節點</li><li>Visualize : 用顏色標示每個群組</li><li>Hide Other Parts When Select : 選取群組時，將現有群組隱藏，以避免誤選</li><li>Attribute : 分類的屬性名稱</li><li>Group Name : 該部位的群組名稱，空白的話不會建立群組</li><li>Primitives : 選取的面編號，按右邊箭頭來選取</li><li>Solo : 單獨顯示部位</li></ul><h2 id="Seperate-EXR-channels-EXR拆通道-COP"><a href="#Seperate-EXR-channels-EXR拆通道-COP" class="headerlink" title="Seperate EXR channels / EXR拆通道 (COP)"></a>Seperate EXR channels / EXR拆通道 (COP)</h2><p><img src="https://i.imgur.com/xemiPmz.png" alt=""></p><blockquote><p><strong>將多通道的EXR照公司算圖方式拆開到各別資料夾</strong></p></blockquote><ul><li>File : 要拆的EXR序列</li><li>Reload : 重新讀取一次</li><li>Start / End : 開始與結束的影格</li><li>Output Elements : 預覽會拆開的元件跟檔名</li><li>Render (Controls) : 算圖跟細項(依影格順序算或元件順序算)</li></ul><h2 id="Tension-張力分析"><a href="#Tension-張力分析" class="headerlink" title="Tension / 張力分析"></a>Tension / 張力分析</h2><p><img src="https://i.imgur.com/2M7y0Pl.png" alt="image alt"></p><blockquote><p><strong>網路的套件，藉由參照物件找出扭曲改變的部分</strong></p></blockquote><h2 id="Transform-by-Alembic-跟隨Alembic位移"><a href="#Transform-by-Alembic-跟隨Alembic位移" class="headerlink" title="Transform by Alembic / 跟隨Alembic位移"></a>Transform by Alembic / 跟隨Alembic位移</h2><p><img src="https://i.imgur.com/AGTI4nL.png" alt="image alt"></p><blockquote><p><strong>找出Alembic的位移資訊並套用</strong></p></blockquote><h2 id="Transform-by-Axis-根據軸向位移"><a href="#Transform-by-Axis-根據軸向位移" class="headerlink" title="Transform by Axis / 根據軸向位移"></a>Transform by Axis / 根據軸向位移</h2><p><img src="https://i.imgur.com/Aw0FmEB.png" alt=""></p><blockquote><p><strong>找出最相符的軸向並依此型變</strong></p></blockquote><ul><li>Axis order : 依照三軸長度由升序排列</li><li>Translate : 位移</li><li>Rotate : 旋轉</li><li>Scale : 縮放</li></ul><h2 id="Transform-by-Matrix-相對Matrix位移"><a href="#Transform-by-Matrix-相對Matrix位移" class="headerlink" title="Transform by Matrix / 相對Matrix位移"></a>Transform by Matrix / 相對Matrix位移</h2><p><img src="https://i.imgur.com/A0rWEMZ.png" alt="image alt"></p><blockquote><p><strong>前一個節點的進階版，抓出input1跟input2的matrix相對位移資訊來移動</strong></p></blockquote><ul><li>Input0 : 要位移的物件</li><li>Input1 : 參考物件</li><li>Input2 : 動態物件</li></ul><h2 id="VDB-Merge-合併VDB"><a href="#VDB-Merge-合併VDB" class="headerlink" title="VDB Merge / 合併VDB"></a>VDB Merge / 合併VDB</h2><p><img src="https://i.imgur.com/YhQBBoh.png" alt=""></p><blockquote><p><strong>合併同一節點的所有VDB</strong></p></blockquote><h2 id="Volume-Vector-Visualize-顯示體積資訊"><a href="#Volume-Vector-Visualize-顯示體積資訊" class="headerlink" title="Volume Vector Visualize / 顯示體積資訊"></a>Volume Vector Visualize / 顯示體積資訊</h2><p><img src="https://i.imgur.com/VQyZ1ua.png" alt="image alt"></p><blockquote><p><strong>視覺化體積資訊，主要用在Vel</strong></p></blockquote><ul><li>Attribute : 要顯示的體積屬性</li><li>Plane : 資訊的切面方向</li><li>Offset : 切面的位移</li><li>Trail Length : 顯示的拖尾長度</li></ul><h2 id="VR-Flipbook-VR預覽"><a href="#VR-Flipbook-VR預覽" class="headerlink" title="VR Flipbook / VR預覽"></a>VR Flipbook / VR預覽</h2><p><img src="https://i.imgur.com/O9Zl60m.png" alt=""></p><blockquote><p><strong>產生360預覽</strong></p></blockquote><ul><li>Start/End : 擷取範圍</li><li>Output Path : 輸出路徑</li><li>Filename : 檔案名稱</li><li>Camera : 要產生的相機</li><li>Resolution : 解析度</li><li>Export Video : 將預覽轉檔成影片，並選擇是否保存原始圖檔序列</li><li>CubeToSphere Path : 應用程式的路徑</li><li>FFMpeg Path : 應用程式的路徑</li></ul><h1 id="流程工具"><a href="#流程工具" class="headerlink" title="流程工具"></a>流程工具</h1><h2 id="Moonshine-Cache-Export-Cache交接輸出"><a href="#Moonshine-Cache-Export-Cache交接輸出" class="headerlink" title="Moonshine Cache Export / Cache交接輸出"></a>Moonshine Cache Export / Cache交接輸出</h2><p><img src="https://i.imgur.com/uMcLtxC.png" alt=""></p><blockquote><p><strong>對MAYA流程的Cache輸出，交接備註與管理</strong></p></blockquote><ul><li>Cache資料夾路徑 : 當設定好專案資訊後會顯示路徑，可複製</li><li>硬碟代號 : 選擇要存在Q槽或者D槽</li><li>Export按鈕 : 輸出Cache，如果是第一次建立該Cache也會新增必須的資料夾</li><li>資料夾按鈕 : 打開保存Cache的資料夾</li><li>複製按鈕 : 從另一個硬碟代號將Cache複製過來，譬如現在在Q槽的某cache_v2，就會從D槽的某cache_v2把檔案複製過來，方便在本機模擬完後再轉移到網路伺服器</li><li>User : 輸出Cache的使用者名稱</li><li>Project : 專案名稱</li><li>Cut : 卡號</li><li>Name : Cache名稱<br>– Name右邊按鈕 : 如果有設定好專案跟卡號，可以直接按此按鈕讀取該卡號的Cache資訊</li><li>Version : 版本號<br>– Add Comment : 增加該版本號備註</li><li>交接留言板<br>– 重新整理按鈕 : 重新整理Cache交接留言板<br>– 中間文字 : 最新一則交接留言版的留言<br>– 氣泡框按鈕 : 觀看所有留言跟新增留言</li><li>Valid Frame Range : 影格輸出方式</li><li>Start/End/Inc : 影格輸出範圍</li><li>Scene Scale : 場景大小</li><li>Seprate : 分別設定場景大小的三軸</li><li>Type : 選擇要輸出Alembic還是VDB</li><li>Alembic :<br>– Render Full Range : 勾選時輸出為一個alembic，取消勾選則輸出多個alembic<br>– Build Hierarchy From Attribute : 由自訂屬性創立階層關係<br>– Path Attribute : 自訂階層屬性</li><li>VDB :<br>– Write 16-Bit Floats : 寫入16位元浮點數格式，壓縮節省Cache空間</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;安裝方法 (二選一)：&lt;br&gt;A - 將 &lt;code&gt;Q:\resource\houdini.env&lt;/code&gt; 複製到 &lt;code&gt;C:\Users\使用者名稱\Documents\houdini16.5&lt;/code&gt; 並覆蓋&lt;br&gt;B - 直接打開 &lt;code&gt;C:\Users\使用者名稱\Documents\houdini16.5\houdini.env&lt;/code&gt;&lt;br&gt;並在最後加上兩行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HOUDINI_OTLSCAN_PATH=&amp;quot;Q:/resource/houdini;@/otls&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HOUDINI_MENU_PATH=&amp;quot;Q:/resource/houdini;@/&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用方式：&lt;br&gt;指令在選單列&lt;code&gt;MoonShine&lt;/code&gt;底下，節點在右鍵(Tab)的&lt;code&gt;Elisha&amp;#39;s Tools&lt;/code&gt;底下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
      <category term="otl" scheme="https://mur.elii.io/tags/otl/"/>
    
  </entry>
  
  <entry>
    <title>Deadline跟Houdini連動筆記</title>
    <link href="https://mur.elii.io/deadline-houdini-intergration/"/>
    <id>https://mur.elii.io/deadline-houdini-intergration/</id>
    <published>2018-04-15T23:52:50.000Z</published>
    <updated>2018-04-21T13:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/deadline-houdini-intergration/01.jpg"><p>將houdini與deadline連接遇到的狀況跟解決方法紀錄在這裡。</p><a id="more"></a><h1 id="Hython版本修改"><a href="#Hython版本修改" class="headerlink" title="Hython版本修改"></a>Hython版本修改</h1><p>不知道為什麼在configure plugins改hython版本沒有用，後來在<br><code>DeadlineRepository\plugins\Houdini\Houdini.param</code>直接修改才順利執行對應版本。</p><h1 id="自製ROP的連動"><a href="#自製ROP的連動" class="headerlink" title="自製ROP的連動"></a>自製ROP的連動</h1><p>houdini在deadline的算圖，是slave會用hython呼叫<code>hrender_dl.py</code>副本並把參數寫進去，<code>hrender_dl.py</code>的主文件位置在<br><code>DeadlineRepository\plugins\Houdini\hrender_dl.py</code>。</p><p>而<code>hrender_dl.py</code>在經過一連串的設定後，是呼叫<code>hou.RopNode.render()</code>來算圖，在這邊用自製ROP遇到問題。</p><p>我在自製的ROP裡有用<code>hou.frame()</code>取現在格數的方式來做計算，如果呼叫<code>hou.RopNode.render()</code>的<code>frame_range</code>參數<code>start</code>跟<code>end</code>是一樣的話(例如<code>(103, 103)</code>)，用<code>hou.frame()</code>取到的值會是1.0，但如果<code>frame_range</code>參數<code>start</code>跟<code>end</code>不一樣(例如<code>(103, 106)</code>)，<code>hou.frame()</code>取到的值就會是正確的103~106。</p><p>解決辦法即是更改<code>hrender_dl.py</code>，加入自製ROP的判斷式用<code>hou.setFrame</code>先移到想要的格數。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...取自hrender_dl.py最後段，以上省略。</span></span><br><span class="line"><span class="keyword">elif</span> ropType == <span class="string">"Redshift_ROP"</span>:</span><br><span class="line">    <span class="comment"># blablabla</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加自製ROP的判斷式，並更改格數讓自製ROP的hou.frame()可以吃到正確格數</span></span><br><span class="line"><span class="keyword">elif</span> ropType == <span class="string">"eli_sepExrRop"</span>:</span><br><span class="line">    <span class="keyword">if</span> startFrame == endFrame:</span><br><span class="line">        hou.setFrame(startFrame)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> tileRender:</span><br><span class="line">    <span class="comment"># blablabla</span></span><br><span class="line"></span><br><span class="line">frameString = <span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> startFrame == endFrame:</span><br><span class="line">    frameString = <span class="string">"frame "</span> + str(startFrame)</span><br><span class="line"><span class="keyword">else</span>:        </span><br><span class="line">    frameString = <span class="string">"frame "</span> + str(startFrame) + <span class="string">" to "</span> + str(endFrame)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isWedge:</span><br><span class="line">    <span class="comment"># blablabla</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print( <span class="string">"Rendering "</span> + frameString )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是一般的自製ROP，整個py只會執行方才增加的判斷式跟下面這行</span></span><br><span class="line">rop.render( frameTuple, resolution, ignore_inputs=ignoreInputs )</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/deadline-houdini-intergration/01.jpg&quot;&gt;
&lt;p&gt;將houdini與deadline連接遇到的狀況跟解決方法紀錄在這裡。&lt;/p&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="tip" scheme="https://mur.elii.io/tags/tip/"/>
    
      <category term="deadline" scheme="https://mur.elii.io/tags/deadline/"/>
    
  </entry>
  
  <entry>
    <title>將iPhone X的臉部追蹤資訊匯到Houdini處理</title>
    <link href="https://mur.elii.io/iphone-x-face-tracking-capture-houdini/"/>
    <id>https://mur.elii.io/iphone-x-face-tracking-capture-houdini/</id>
    <published>2017-11-18T23:26:34.000Z</published>
    <updated>2018-04-21T13:33:27.000Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container"><iframe src="//player.vimeo.com/video/242626624" frameborder="0" allowfullscreen></iframe></div><p>入手iphone X後，前幾天開始好奇是不是可以來玩些什麼，於是去翻翻關於臉部追蹤的資料庫，發現蘋果對於這塊的API寫得很好，可以輕鬆取得相關追蹤資訊。於是就研究了些方法，讓資料可以帶到Houdini。</p><p>紀錄一下這幾天研究的一些心得。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上面的影片是用擷取好的資料在houdini重現，另外將捕捉時的圖像序列存下來，放在旁邊對照，造成有些人誤會是即時的。</p><p>但的確有另外做即時串流的捕捉模式，如下圖範例，不過就沒有辦法串流圖像，可以看到臉部生硬很多。(格率不夠是quicktime擷取4K螢幕的問題，手機APP跟伺服器當下是每秒60格運作的)<br><video src="/iphone-x-face-tracking-capture-houdini/01.mp4" autoplay loop></video></p><p>先附上這次的<a href="https://github.com/elishahung/FaceCaptureX" target="_blank" rel="noopener">GitHub原始碼</a>，程式基礎很淺，有點亂請見諒。</p><p>整體的流程，分客戶端跟伺服器端：</p><ul><li>客戶端：在iphone X上寫一個APP，可以將臉部的追蹤資訊以串流送出或者儲存在手機。</li><li>伺服器端：在houdini上讀取資料，串流模式下架設伺服器接收臉部資訊封包，並將資料轉換成動態。</li></ul><h1 id="客戶端-iPhone-Swift"><a href="#客戶端-iPhone-Swift" class="headerlink" title="客戶端(iPhone, Swift)"></a>客戶端(iPhone, Swift)</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><img src="/iphone-x-face-tracking-capture-houdini/02.jpg"><p>陽春的介面：錄製模式、串流模式、細節設定，和一顆錄製Capture按鈕</p><p>臉部追蹤的部分是用到ARKit(連接SceneKit)，這邊蘋果已經幫我們準備得非常完善，追蹤運算那些深層都不用管，只要拿結果資料就好。</p><p>ARKit的細節就不詳述了，<a href="http://blog.csdn.net/u013263917/article/details/73038519" target="_blank" rel="noopener">網路上有非常多文章寫得不錯</a>，<a href="https://developer.apple.com/videos/play/fall2017/601/" target="_blank" rel="noopener">WWDC2017也有很多長知識的影片</a>。現在相關文章大多都是一般的場景AR，而不是關於臉部的AR，不過大同小異，基礎的架構是一致的，蘋果研發網站的文件相當齊全，<a href="https://developer.apple.com/documentation/arkit/creating_face_based_ar_experiences" target="_blank" rel="noopener">也有範例檔案跟說明</a>，幾小時就能上手。</p><p>接下來所說的大部分在GitHub的程式碼都有註解，不再多做贅述。</p><p>客戶端這邊的流程是：</p><blockquote><p>從AR框架取得資訊 -&gt; 將資訊整理 -&gt; 看是要串流封包給伺服器還是存檔在應用程式資料夾</p></blockquote><p>要取得的有：<strong>臉部頂點資訊、臉部transform、臉部blendshape資料、攝影機transform、攝影機圖像</strong></p><h2 id="臉部頂點資訊"><a href="#臉部頂點資訊" class="headerlink" title="臉部頂點資訊"></a>臉部頂點資訊</h2><p>ARKit主要的追蹤資料是存在<code>ARSession.currentFrame</code>裡面，也就是目前當格的追蹤資訊(<code>ARSession</code>預設捕捉是每秒60格)，臉部追蹤時只會有一個<code>ARAnchor</code>，如果畫面有兩個臉也只會針對比較明顯的去做追蹤， 而臉部的<code>ARAnchor</code>有一個專屬繼承類別叫<code>ARFaceAnchor</code>，就存有臉部模型與頂點位置資訊，用<code>ARFaceAnchor.geometry.vertices</code>可取出向量陣列。</p><h2 id="臉部transform"><a href="#臉部transform" class="headerlink" title="臉部transform"></a>臉部transform</h2><p>方才只有臉部頂點的資訊，類似表情這樣(<a href="https://vimeo.com/242460460" target="_blank" rel="noopener">像這影片</a>)，那還需要旋轉位移等資訊才能移動頭部，同上從<code>ARAnchor.transform</code>拿到matrix4資訊。</p><h2 id="臉部blendshape"><a href="#臉部blendshape" class="headerlink" title="臉部blendshape"></a>臉部blendshape</h2><p>除了頂點資訊來做表情，還有更原生的blendshape資料可以拿，詳細的blendshape列表<a href="https://developer.apple.com/documentation/arkit/arfaceanchor.blendshapelocation" target="_blank" rel="noopener">可以查看蘋果研發網站</a>，還會有圖片清楚示意每個blendshape的morph。這個資料一樣要從<code>ARFaceAnchor.blendShapes</code>取得(得到的類型是字典)。</p><h2 id="攝影機transform"><a href="#攝影機transform" class="headerlink" title="攝影機transform"></a>攝影機transform</h2><p>跟臉部一樣，是matrix4，這個攝影機資訊拿到是要在houdini裡面做投影貼圖用，結合待會要說的攝影機圖像。<code>ARSession.currentFrame.camera</code>可以拿到<code>ARCamera</code>，就是追蹤環境下當格的攝影機資料(還有追蹤狀況品質等)，再從<code>ARCamera.transform</code>取得位移。</p><h2 id="攝影機圖像"><a href="#攝影機圖像" class="headerlink" title="攝影機圖像"></a>攝影機圖像</h2><p>從<code>ARSession.currentFrame.captureImage</code>得到當格追蹤參考的圖像，解析度是1280x720，比較要注意的是取得的型態是YUV的<code>CVPixelBuffer</code>，要存成JPG或PNG需要再進行一些步驟，寫在GitHub原始檔的<code>Extensions.swift</code>裡。</p><img src="/iphone-x-face-tracking-capture-houdini/03.jpg"><p>取得資訊後，要轉換成字串以便寫成檔案或串流，詳細的方法也寫在<code>Extension.swift</code>裡，就是很陽春的轉成字串並分隔，時間格由每行分開，每種資料之間由”~”分開，資料自己再以”:”分開。<br>浮點數包含”e”這種的轉成字串沒有關係，houdini是可以轉回去的，blendshape資訊也是如此。</p><p>取得資訊、資訊轉成字串都好了，接下來是輸出。<br>分成兩類：<strong>Record錄製、Stream串流</strong></p><h2 id="Record錄製"><a href="#Record錄製" class="headerlink" title="Record錄製"></a>Record錄製</h2><p>錄製比較需要的是可以自訂FPS，用<code>Timer.scheduledTimer</code>去做到這點。</p><p>錄製的流程是：每次執行捕捉時都將資料暫存陣列，而攝影機圖像就先存成JPG。錄製完後，將捕捉暫存陣列轉換成字串寫成txt文字檔，跟方才陸續存成的圖像序列都放在APP下documentary建立資料夾打包。</p><p>每格的圖像處理是另外的queue去跑，主執行還是跑捕捉，只是會把圖像資料丟給這個queue，queue再自行轉成jpg跟寫檔，queue在執行這過程要再包一個<code>autoreleasepool</code>，不包的話，跑<code>UIImageJPEGRepresentation</code>會讓記憶體瞬間衝滿，不會釋放。</p><img src="/iphone-x-face-tracking-capture-houdini/03_.jpg"><p>錄製的檔案以錄製時間分類資料夾，從itunes可以輕易取出</p><h2 id="Stream串流"><a href="#Stream串流" class="headerlink" title="Stream串流"></a>Stream串流</h2><p>串流這塊很棘手，其實這幾天研究下來有絕大部分的時間都在處理這塊，對於網路和檔案傳送這塊不是很了解。</p><p>跟錄製從<code>Timer.scheduledTimer</code>執行不一樣的是，串流是由<code>ARSession</code>的<code>delegate：didupdate</code>來執行，也就是捕捉的每格都會串流，來做到最即時的反應。</p><p>用<code>Stream.getStreamsToHost</code>取得outputStream連接伺服器端，再將取得的資料轉成字串輸出，而每格的總執行時間要低於0.016秒，才能穩定60格輸出。當然還有傳的資料最後加上結尾字符，跟出錯時提醒伺服器停止接收等必須動作。<br>至於圖像的串流目前能力還做不到。</p><h1 id="伺服器端-Houdini-Python-Vex"><a href="#伺服器端-Houdini-Python-Vex" class="headerlink" title="伺服器端(Houdini, Python, Vex)"></a>伺服器端(Houdini, Python, Vex)</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h2><p>伺服器端完全在houdini裡面搭建，先建立整體架構，用Python SOP匯入錄製資料，串流部分則利用<code>hou.session</code>(python source editor)完成接收伺服器的編寫。<br>blendshape資訊在這流程下其實沒有用到，只是提供一個取出來的方法，以供之後有搭配rig的角色使用。</p><p>整體節點如下圖所示：<br><img src="/iphone-x-face-tracking-capture-houdini/04.jpg"><br>由讀取臉部模型的faceGeo當起始，以<strong>Record錄製</strong>跟<strong>Stream串流</strong>兩種模式來分成兩大區塊。</p><p><strong>faceGeo</strong><br>讀取一個臉部模型的bgeo.sc檔案(GitHub有附)，這是利用Xcode擷取出Scenekit的Collada檔案轉換而來，也就是<code>ARFaceGeometry</code>的模型。目前還不知道怎麼利用Model I/O匯出模型，既然臉部頂點都一樣，都是用同一個拓樸去貼合臉型，就沒必要每次都擷取模型。</p><h2 id="Record-Mode區塊"><a href="#Record-Mode區塊" class="headerlink" title="Record Mode區塊"></a>Record Mode區塊</h2><p><strong>material</strong><br>上一個unlit材質，並上臉部貼圖，材質的貼圖路徑是跟getRecordData連動的(去取得該路徑資料夾下的臉部圖像序列)。</p><p><strong>getRecordData</strong><br>Python Sop，這區塊的核心，選擇錄製資訊的資料夾，之後都幫你轉換好。滿意外的是貌似只讀取一次文字檔，之後拖曳時間軸順暢沒壓力，也不會有重複硬碟讀取。<br>這邊是去抓指定資料夾裡的faceData.txt，並將資料解析給各頂點設定位置，然後將攝影機跟臉部的transform跟blendshapes給放到detail屬性裡。<br><img src="/iphone-x-face-tracking-capture-houdini/05.jpg"><br>houdini 16.5新增的選擇資料夾parm，突破以往只能選檔案的限制，也使得這個hip只能用16.5開啟。</p><p><strong>vex_faceAni</strong><br>然後將已經移動完位置的頂點套上臉部matrix資訊。</p><p><strong>vex_camTrans</strong><br>將攝影機的matrix解出位移跟旋轉，其實AR攝影機只會有旋轉的資訊。這個資訊會套在根路徑的投影貼圖專用攝影機。</p><p><strong>vex_projectUV</strong><br>投影貼圖的攝影機套上位移後，取得攝影機跟頂點的相對位置，投影成頂點的uv。這樣錄製的部分就完成了。</p><h2 id="Stream-Mode區塊"><a href="#Stream-Mode區塊" class="headerlink" title="Stream Mode區塊"></a>Stream Mode區塊</h2><p><strong>useMapping</strong><br>因為串流模式沒有串流貼圖，可以先用錄製模式取得的某格貼圖跟uv去上在模型上。</p><p><strong>streamServer</strong><br>這區塊的核心，伺服器IP設定、開關控制，以及用接收的資訊去驅動模型。<br>在這邊新增按鈕，跟<code>hou.session</code>做連動控制伺服器的開關跟設定IP，並有一個隱藏的字串<code>parm(&quot;datas&quot;)</code>去接受串流得到的捕捉資訊，code的wrangle部分再用這個<code>parm(&quot;datas&quot;)</code>去移動頂點。<br><img src="/iphone-x-face-tracking-capture-houdini/06.jpg"></p><p><strong>hou.session module</strong><br>跟iPhone X 串流溝通的部分是寫在這裡，也就是存在hip本身裡面的python檔，將公式定義在這裡，方便修改以及跟streamServer節點的按鈕連動。<br><img src="/iphone-x-face-tracking-capture-houdini/07.png"></p><p>接收的伺服器制定了兩個執行緒，一個執行緒持續接收iPhone X這邊的封包，並將接收好的封包丟在一個queue，另一個執行緒持續等著這個queue，這個queue一有東西便馬上拿出來放到streamServer的<code>parm(&quot;datas&quot;)</code>裡。<br>這邊兩個執行緒都會持續播報每秒執行的資料數量，正常來說應該都要是print <code>60, 60，</code>而houdini viewport更新的部分可能礙於顯示效能，會是30~60fps跑。</p><p>伺服器端的部分大抵是這樣，其實東西都很簡單，但學習串流的部分花了很多時間，到目前為止其實都還不算穩定，有時候也會因不明原因延遲，要重新接幾次才會順暢60格跑。至於圖像串流，曾經試過將圖像轉成jpg後用base64方式去傳，但都會略高於1/60秒的處理時間，更何況還有houdini這邊圖像更新所需的時間，還是將這種事情留給unreal或者unity做吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//player.vimeo.com/video/242626624&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;入手iphone X後，前幾天開始好奇是不是可以來玩些什麼，於是去翻翻關於臉部追蹤的資料庫，發現蘋果對於這塊的API寫得很好，可以輕鬆取得相關追蹤資訊。於是就研究了些方法，讓資料可以帶到Houdini。&lt;/p&gt;
&lt;p&gt;紀錄一下這幾天研究的一些心得。&lt;/p&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
      <category term="python" scheme="https://mur.elii.io/tags/python/"/>
    
      <category term="swift" scheme="https://mur.elii.io/tags/swift/"/>
    
      <category term="ar" scheme="https://mur.elii.io/tags/ar/"/>
    
  </entry>
  
  <entry>
    <title>Houdini針對攝影機範圍做粒子的裁切輕量化</title>
    <link href="https://mur.elii.io/houdini-crop-tondc-particle/"/>
    <id>https://mur.elii.io/houdini-crop-tondc-particle/</id>
    <published>2017-09-03T23:15:46.000Z</published>
    <updated>2018-04-21T17:57:42.000Z</updated>
    
    <content type="html"><![CDATA[<video src="/houdini-crop-tondc-particle/01.mp4" autoplay loop></video><p>在將houdini的特效輸出到其他軟體時，有許多輕量化的撇步。<br>這裡介紹一種很常用的依照攝影機看到範圍去裁切的方法。</p><a id="more"></a><h1 id="模型準備"><a href="#模型準備" class="headerlink" title="模型準備"></a>模型準備</h1><img src="/houdini-crop-tondc-particle/02.png"><p>準備了一隻豬，並用scatter撒上大量的點。</p><img src="/houdini-crop-tondc-particle/03.png"><p>在攝影機視角看到的會是這樣，有很多粒子都不在攝影機看到的範圍。</p><h1 id="裁切vex"><a href="#裁切vex" class="headerlink" title="裁切vex"></a>裁切vex</h1><img src="/houdini-crop-tondc-particle/04.png"><p>下attribute wrangle，用vex來寫裁切的描述。</p><img src="/houdini-crop-tondc-particle/05.png"><p>如註釋所解釋：</p><ul><li>建立一個向量變數，取名叫<code>ndc</code>，用來取得點在攝影機的相對位置，稍後會針對<code>toNDC</code>做進一步解釋。</li><li>建立一個浮點變數，取名叫<code>offset</code>，用來微調，因為通常會去取比攝影機的正確範圍稍大點的值去做篩選。</li><li>定義兩個篩選用的邊緣值。</li><li>用<code>ndc</code>的<code>x</code>、<code>y</code>去判斷是否超出邊緣，超出邊緣即刪除。這邊沒有做Z值的判斷，通常Z值會用<code>ndc.z &gt; 0</code>來做刪除，代表已經跑到攝影機後面。</li></ul><img src="/houdini-crop-tondc-particle/06.png"><p>前面輸入<code>chs(&quot;cam&quot;)</code>後，自動產生parameter會是string類別，可以將它編輯成operator path，並指定只能選擇攝影機，以方便使用者選取。</p><h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><img src="/houdini-crop-tondc-particle/07.png"><p>這樣便可以將粒子篩到剩下攝影機的範圍再輸出，節省不少空間，也能增進讀取效能。<br>不只粒子，有很多太重的cache也可以用相同的方法去做延伸。</p><img src="/houdini-crop-tondc-particle/08.png"><p>關於<code>toNDC</code>，它是會取出位置(粒子座標)在物件(攝影機)的相對位子，<code>x</code>跟<code>y</code>的邊緣是0~1(不會clamp)，那<code>z</code>的話就是以攝影機位置為0，向後是正的增加，向前是負的減少，用這三個得到一個向量值。</p><a href="/houdini-crop-tondc-particle/demo.hip" title="範例檔案">範例檔案</a>]]></content>
    
    <summary type="html">
    
      &lt;video src=&quot;/houdini-crop-tondc-particle/01.mp4&quot; autoplay loop&gt;&lt;/video&gt;
&lt;p&gt;在將houdini的特效輸出到其他軟體時，有許多輕量化的撇步。&lt;br&gt;這裡介紹一種很常用的依照攝影機看到範圍去裁切的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="tip" scheme="https://mur.elii.io/tags/tip/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
      <category term="particle" scheme="https://mur.elii.io/tags/particle/"/>
    
  </entry>
  
  <entry>
    <title>Houdini快速製作類似Diablo天使的虛化翅膀效果</title>
    <link href="https://mur.elii.io/houdini-diablo-wing-aurora/"/>
    <id>https://mur.elii.io/houdini-diablo-wing-aurora/</id>
    <published>2017-08-31T23:04:58.000Z</published>
    <updated>2018-04-20T23:24:37.000Z</updated>
    
    <content type="html"><![CDATA[<video src="/houdini-diablo-wing-aurora/01.mp4" autoplay loop></video><p>去年一個案子要做出類似暗黑破壞神的天使翅膀。<br>運用wire capture操縱turbulence的翅膀片狀，並調整適當shader，幾乎可以做到即時預覽。<br>也可以拿來做為靈氣(aurora)之類的效果，免去用大量praticle堆疊。</p><a id="more"></a><h1 id="導引骨架"><a href="#導引骨架" class="headerlink" title="導引骨架"></a>導引骨架</h1><video src="/houdini-diablo-wing-aurora/02.mp4" autoplay loop></video><p>一開始用wire solver簡單做出幾個動態的線條，在這邊稱為翅膀的導引線，每個導引線都是一個primitive，並且每點等距。</p><p>加上measure算出每個導引線的長度，接著用foreach針對每個導引線做權重綁定處理。</p><h1 id="權重綁定"><a href="#權重綁定" class="headerlink" title="權重綁定"></a>權重綁定</h1><img src="/houdini-diablo-wing-aurora/03.png"><p>製作出一個和導引線等長的片狀翅膀，以X軸為基準。</p><img src="/houdini-diablo-wing-aurora/04.png"><p>翅膀完成後，讓導引線的每個點根據自己的點編號順序排在X軸上，與翅膀對齊，便可以用wire capture算出翅膀在導引線上的權重。</p><h1 id="增加動態"><a href="#增加動態" class="headerlink" title="增加動態"></a>增加動態</h1><img src="/houdini-diablo-wing-aurora/05.png"><p>加上turbulence，注意freq的比例、隨時間增加的offset，這邊的扭曲是算圖效果的關鍵。</p><p>另外有做twist去豐富動態細節，要注意的是隨著每根翅膀不同，要有不同的seed才有多樣化的層次。</p><img src="/houdini-diablo-wing-aurora/06.png"><p>翅膀本身型態調完後，就可以添加wire deform去跟隨導引線的動態，到這邊基本上模型的部分就完成了，剩下的是一些修飾，像根據導引線頭尾位置添加顏色漸層，或者smooth修順形狀。</p><h1 id="材質"><a href="#材質" class="headerlink" title="材質"></a>材質</h1><p>shader則是創造一個constant預設材質球。<br><img src="/houdini-diablo-wing-aurora/07.png"><br>進到內部，加上normal falloff去相乘color，以及當成opacity。然後調整normal falloff的參數，去抓出翅膀扭曲部分的漸層。</p><img src="/houdini-diablo-wing-aurora/08.png"><p>測算單張，算圖時間僅需3秒。</p><p>整個流程只要修改導引線便可以更改動態，而翅膀的細節則由turbulence去控制，彈性很高，相同概念可以用在很多地方。</p><p>最後附上<a href="/houdini-diablo-wing-aurora/demo.hip" title="示範hip檔">示範hip檔</a></p>]]></content>
    
    <summary type="html">
    
      &lt;video src=&quot;/houdini-diablo-wing-aurora/01.mp4&quot; autoplay loop&gt;&lt;/video&gt;
&lt;p&gt;去年一個案子要做出類似暗黑破壞神的天使翅膀。&lt;br&gt;運用wire capture操縱turbulence的翅膀片狀，並調整適當shader，幾乎可以做到即時預覽。&lt;br&gt;也可以拿來做為靈氣(aurora)之類的效果，免去用大量praticle堆疊。&lt;/p&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
      <category term="shader" scheme="https://mur.elii.io/tags/shader/"/>
    
      <category term="wire" scheme="https://mur.elii.io/tags/wire/"/>
    
  </entry>
  
  <entry>
    <title>用Pixpro SP360 4K錄製立體180度VR影片</title>
    <link href="https://mur.elii.io/pixpro-sp360-4k-180-vr-video/"/>
    <id>https://mur.elii.io/pixpro-sp360-4k-180-vr-video/</id>
    <published>2016-12-19T22:38:43.000Z</published>
    <updated>2018-04-21T18:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/pixpro-sp360-4k-180-vr-video/01.jpg"><p>比起一般360影片，正面180度的立體影片可說是沉浸感更高的影片類型，一般360只是像在一個球形螢幕裡面四周看，而立體影片會讓你身歷其境，或許一開始會有只有180度的疑慮，但其實稍微左顧右盼已經足夠，很少會有想轉到身後的時候。</p><p>PIXPRO SP360 4K是一台可以錄製超廣角的運動攝影機，也可以買兩台同時攝影，縫成360環景影片。但它其實也非常適合去錄製雙眼立體正面180度VR影片。</p><p>下面便介紹硬體設備的準備，以及影片處理的一些流程。</p><a id="more"></a><h1 id="硬體設備"><a href="#硬體設備" class="headerlink" title="硬體設備"></a>硬體設備</h1><h2 id="Kodak-SP360-4K"><a href="#Kodak-SP360-4K" class="headerlink" title="Kodak SP360 4K"></a>Kodak SP360 4K</h2><img src="/pixpro-sp360-4k-180-vr-video/02.jpg"><p>SP360 4K(特別指雙機組)非常適合拿來拍攝180度VR立體影片。</p><ul><li>單機拍攝具有235度的視野。</li><li>有遙控器可以同時控制兩台錄製(大約只會有1~2格時間差)。</li><li>拍出來是2880x2880的魚眼原始檔，易於後期處理，甚至可以做出5760x2880的高解析影片。</li><li>可能因為規格特別，還需要兩台才能拍360比較麻煩，較不受消費者青睞，價錢下殺頗大。</li></ul><h2 id="立體支架"><a href="#立體支架" class="headerlink" title="立體支架"></a>立體支架</h2><p>有了兩台SP360 4K跟遙控器，接下來需要可以讓兩個攝影機平行拍攝的支架。</p><p>目前能找得到的專用支架都是3D列印的，一種是可以從eBay、淘寶購得，另一種是這位<a href="http://rocketpictures.net/3D/" target="_blank" rel="noopener">Mark先生的特別製作</a>並有詳細心得解說。</p><img src="/pixpro-sp360-4k-180-vr-video/03.jpg"><p>本篇所使用的是淘寶購入的版本。</p><h2 id="三軸穩定器"><a href="#三軸穩定器" class="headerlink" title="三軸穩定器"></a>三軸穩定器</h2><p>最後一個非常重要的設備是三軸穩定器，<strong>如果沒有三軸穩定器，你只能架在腳架上立定拍攝。</strong></p><p>因為就算輕微地震動，都會嚴重影響觀看時的舒適度，容易暈眩出戲。</p><p>但如果有三軸穩定器，你手持著像常人一樣走路爬山都沒問題(當然還是能穩盡量穩)。</p><p>而且三軸穩定器能讓你持續保持水平，而拍攝立體VR最重要的就是保持水平，不仰不俯，是觀看的人自己要去抬頭低頭。</p><p>不過就算有三軸穩定器，還是要練習如何「轉彎」，這是會影響舒適度的一個大環節。</p><img src="/pixpro-sp360-4k-180-vr-video/04.jpg"><p>這裡使用的是智雲Zhiyun Crane-M，是一支可續航12小時的輕便三軸穩定器，雖然只能承重650g，但配著兩台SP360 4K恰到好處。平常就像上圖的組裝方式，收納在背包裡，出去旅遊時便可以隨時拿出來紀錄一段。</p><h1 id="後製處理"><a href="#後製處理" class="headerlink" title="後製處理"></a>後製處理</h1><p>接下來說明拍攝完的處理步驟。</p><h2 id="攤平素材"><a href="#攤平素材" class="headerlink" title="攤平素材"></a>攤平素材</h2><img src="/pixpro-sp360-4k-180-vr-video/05.jpg"><p>拍完後的素材，如圖是2880x2880的魚眼影片，要先將魚眼的原始素材展開成Equirectangular(等距長方投影)。</p><p>展開的方式，嘗試過Autopano、AE的RE:lens、Nuke的CARA VR，結果仍不如官方附屬程式360stitch來得好(CARA VR很接近，但還是有些落差)，可惜360stitch非常陽春，就只能縫合輸出3840x2160影片，沒有細節參數可以調整。</p><p>360stitch本意是將兩台機器拍攝的影片接成360，但我們只是拿來展開，所以便把兩個影片都設為同個影片輸出，結果如下：<br><img src="/pixpro-sp360-4k-180-vr-video/06.jpg"><br>注意將接縫設定為「銳利」。</p><h2 id="疊合左右眼"><a href="#疊合左右眼" class="headerlink" title="疊合左右眼"></a>疊合左右眼</h2><p>將左右眼都展開後，因為要傳到youtube，所以採用Over/Under上下立體拼接：將左眼擺在上層，右眼擺在下層疊起來。</p><p>拼接完後，還必須給上一層mask去遮住不需要看到的地方，譬如後面180度範圍，以及左右眼會看到彼此鏡頭的部分。</p><p>在這邊我是直接按照影片截圖去做了一張透明PNG。<br><img src="/pixpro-sp360-4k-180-vr-video/07.png"></p><p>處理完的結果就是一個4096x4096的360立體影片(但後面180度是遮住的)：<br><img src="/pixpro-sp360-4k-180-vr-video/08.jpg"></p><h2 id="批次處理"><a href="#批次處理" class="headerlink" title="批次處理"></a>批次處理</h2><p>許多網路上的方法都是用Premiere、Finalcut或者AE去做上述步驟的處理，但如果你拍攝很多片段，這是很耗時的事情，更何況只是簡單的兩個步驟：疊加影片-&gt;蓋上遮罩。</p><p>所以這邊我是用Python配上ffmpeg去做批次處理 (如果cmd指令夠強其實也不用進到python)</p><img src="/pixpro-sp360-4k-180-vr-video/09.png"><p>像這樣已經用stitch360輸出影片並命好名稱(這步驟避免不了，真心希望柯達可以開放command line)<br>另外要注意的是用stitch360輸出前可以先將左右兩眼影片拖進程式，去讓程式判斷聲音同步的誤差，通常是0~2格。</p><p>接著執行下面script(ffmpeg已經有設定PATH環境變數)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob, subprocess, os</span><br><span class="line"></span><br><span class="line">video_list = glob.glob(<span class="string">"*_l.mp4"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> video_file <span class="keyword">in</span> video_list:</span><br><span class="line">    video_name = video_file.replace(<span class="string">"_l.mp4"</span>, <span class="string">""</span>)</span><br><span class="line">    cmd = <span class="string">'ffmpeg -i &#123;0&#125;_l.mp4 -i &#123;0&#125;_r.mp4 -i mask_360.png -filter_complex "[0:v]pad=iw:ih*2[base]; [base][1:v]overlay=0:H/2:shortest=1[over]; [over][2:0]overlay=0:0[output]" -map [output] -map 0:a:0 -c:v libx264 -crf 17 -y output/&#123;0&#125;.mp4'</span>.format(video_name)</span><br><span class="line">    subprocess.call(cmd, shell=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>整個script用意就是蒐集影片，合併並貼上遮罩輸出。</p><h2 id="快速剪輯"><a href="#快速剪輯" class="headerlink" title="快速剪輯"></a>快速剪輯</h2><p>一般來說到這邊，影片就完成了。</p><p>但如果你想要剪接，用一般編輯軟體，4096x4096的高解析度，又慢又會二次轉碼損傷畫質。<br>於是也手動一點，用ffmpeg做無編碼剪輯，雖然剪接點可能會有點小落差，不過通常這種VR立體展示影片是不會太計較，而且輸出幾秒就可以完成。</p><img src="/pixpro-sp360-4k-180-vr-video/10.png"><p>這些是照上一步驟輸出已合併的立體影片，建立一個edit.txt文字檔並把檔名跟剪接的in、out點寫上，讓script去做剪裁跟合併的依據。</p><p>edit.txt內容範例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 20 1:20</span><br><span class="line">02 37 2:40</span><br><span class="line">03 1:03 2:27</span><br><span class="line">03 4:08 5:31</span><br><span class="line">04 1:33 2:19</span><br></pre></td></tr></table></figure></p><p>Script內容：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess, os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">duration</span><span class="params">(st, et)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cnvSecs</span><span class="params">(t)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> t.find(<span class="string">":"</span>) != <span class="number">-1</span>:</span><br><span class="line">            t_s = t.split(<span class="string">":"</span>)</span><br><span class="line">            ct = int(t_s[<span class="number">0</span>])*<span class="number">60</span> + int(t_s[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ct = int(t)</span><br><span class="line">        <span class="keyword">return</span> ct   </span><br><span class="line">    <span class="keyword">return</span> str(cnvSecs(et) - cnvSecs(st))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmdEdit</span><span class="params">(filename, st, et, outputname)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ffmpeg -ss &#123;0&#125; -i &#123;1&#125;.mp4 -t &#123;2&#125; -c copy -avoid_negative_ts 1 -y &#123;3&#125;.mp4"</span>.format(st, filename, duration(st, et), outputname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'edit.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_list = f.read().splitlines()</span><br><span class="line"></span><br><span class="line">output_list = []</span><br><span class="line"><span class="keyword">for</span> idx, l <span class="keyword">in</span> enumerate(f_list, <span class="number">1</span>):</span><br><span class="line">    cmds = l.split(<span class="string">" "</span>)</span><br><span class="line">    outputname = <span class="string">"edit_&#123;0&#125;"</span>.format(idx)</span><br><span class="line">    output_list.append(outputname)</span><br><span class="line">    subprocess.call(cmdEdit(cmds[<span class="number">0</span>], cmds[<span class="number">1</span>], cmds[<span class="number">2</span>], outputname), shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">edit_list = [<span class="string">"file '"</span> + s + <span class="string">".mp4'\n"</span> <span class="keyword">for</span> s <span class="keyword">in</span> output_list]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'temp.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">""</span>.join(edit_list))</span><br><span class="line">subprocess.call(<span class="string">"ffmpeg -f concat -i temp.txt -c copy edited.mp4"</span>, shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">remove_list = [s + <span class="string">".mp4"</span> <span class="keyword">for</span> s <span class="keyword">in</span> output_list]</span><br><span class="line">remove_list.append(<span class="string">"temp.txt"</span>)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> remove_list:</span><br><span class="line">    os.remove(file)</span><br></pre></td></tr></table></figure></p><p>其實網路上也有些免編碼帶UI的剪輯程式可以方便使用。</p><p>另外，如果沒有要上傳到youtube需求，其實side by side的方式可以簡潔一點，因為只要4096x2048的尺寸，不需要留後面180度的黑幕，不過其實容量差不多。</p><p>這邊留有之前side by side的bat內容：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input_l.mp4 -i input_r.mp4 -i mask_180.png -filter_complex ^</span><br><span class="line"><span class="string">"[0:v]crop=1920:1920:960:0[crop_left]; ^</span></span><br><span class="line"><span class="string">[1:v]crop=1920:1920:960:0[crop_right]; ^</span></span><br><span class="line"><span class="string">[crop_left]pad=iw*2:ih[base]; ^</span></span><br><span class="line"><span class="string">[base][crop_right]overlay=W/2:0:shortest=1[sth]; ^</span></span><br><span class="line"><span class="string">[sth][2:0]overlay=0:0[output] ^</span></span><br><span class="line"><span class="string">"</span> -map [output] -map <span class="number">0</span>:a:<span class="number">0</span> -c:v libx264 -crf <span class="number">17</span> -y VRsbs.mp4</span><br></pre></td></tr></table></figure></p><h1 id="範例影片"><a href="#範例影片" class="headerlink" title="範例影片"></a>範例影片</h1><p>最後附上最近錄製的幾段影片，youtube這邊要看原始解析度可能會很頓，所以也附上影片原始檔連結，在手機用橙子vr或者在電腦用virtual desktop選擇360 Over-under觀看。</p><div class="video-container"><iframe src="//www.youtube.com/embed/BDvY2QlTh-o" frameborder="0" allowfullscreen></iframe></div><div class="video-container"><iframe src="//www.youtube.com/embed/J8lIMyTFFN8" frameborder="0" allowfullscreen></iframe></div><div class="video-container"><iframe src="//www.youtube.com/embed/fxI6hQTgpL0" frameborder="0" allowfullscreen></iframe></div>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/pixpro-sp360-4k-180-vr-video/01.jpg&quot;&gt;
&lt;p&gt;比起一般360影片，正面180度的立體影片可說是沉浸感更高的影片類型，一般360只是像在一個球形螢幕裡面四周看，而立體影片會讓你身歷其境，或許一開始會有只有180度的疑慮，但其實稍微左顧右盼已經足夠，很少會有想轉到身後的時候。&lt;/p&gt;
&lt;p&gt;PIXPRO SP360 4K是一台可以錄製超廣角的運動攝影機，也可以買兩台同時攝影，縫成360環景影片。但它其實也非常適合去錄製雙眼立體正面180度VR影片。&lt;/p&gt;
&lt;p&gt;下面便介紹硬體設備的準備，以及影片處理的一些流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://mur.elii.io/tags/python/"/>
    
      <category term="vr" scheme="https://mur.elii.io/tags/vr/"/>
    
      <category term="vive" scheme="https://mur.elii.io/tags/vive/"/>
    
      <category term="camera" scheme="https://mur.elii.io/tags/camera/"/>
    
  </entry>
  
  <entry>
    <title>用HTC Vive看Cardboard Camera的照片</title>
    <link href="https://mur.elii.io/cardboard-camera-htc-vive/"/>
    <id>https://mur.elii.io/cardboard-camera-htc-vive/</id>
    <published>2016-11-22T22:14:57.000Z</published>
    <updated>2018-04-21T18:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container"><iframe src="//player.vimeo.com/video/192793926" frameborder="0" allowfullscreen></iframe></div><p>Google 在 Android/iOS 雙平台推出的 Cardboard Camera，算是目前看過效果最好的360立體照片軟體之一，而且拍攝極其方便簡單，就可以產生出約10000像素寬的高解析立體照片。<br>問題是，這照片只能在手機自己的APP看，從手機的相簿或者傳到電腦上，會發現只有一張照片。</p><p>這問題在 <a href="http://vectorcult.com/2015/12/extracting-the-audio-stereo-pair-from-cardboard-camera-3d-panoramic-images/" target="_blank" rel="noopener">Vector Cult VR</a> 的文章 有很詳盡的解釋。</p><a id="more"></a><h1 id="圖檔結構跟解出原始檔"><a href="#圖檔結構跟解出原始檔" class="headerlink" title="圖檔結構跟解出原始檔"></a>圖檔結構跟解出原始檔</h1><p>原來右眼的照片跟錄製時的環境音檔都存在這張Jpg的中繼資料裡面，XMP竟然可以保存這麼多格式。<br>知道原理後，便著手開始寫轉換的script，取得jpg中所需的資料，包括右眼圖檔、上下的裁高，把上下不足的地方補回去打糊，就像手機APP觀看的方式一樣。</p><p>Vector Cult 在文章所使用提取Jpg中繼資料的方法是用 Python XMP Toolkit，但是這模組在windows無法編譯，所以轉個彎採exiftool用<code>subprocess</code>方式去接收資料。</p><p>因為想以後可以直接拖曳想要轉檔的jpg到程式就可以直接轉，所以這邊寫了一個bat，來跟py做連結，畢竟沒辦法直接把檔案拖曳到py上。</p><p>bat這邊就很簡單的寫上一行：<br><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">python "%~dp0cb.py" %~dp0 %*</span><br></pre></td></tr></table></figure></p><p>來把bat所在路徑跟拖曳檔案的資訊傳到py裡。</p><p>取得所有圖檔所在後便開始批次處理，首先用exiftool取得拍攝的細節資訊，了解到上下被裁切了多少，這些資訊等等圖像處理時會用到。<br>另外也用<code>exiftool -b</code>的方式把圖檔的右眼照片提取出來，提出來會是binary資料，用stringIO暫存下來給pillow用，就不用還另外存一個jpg檔。<br>值得注意的是，提出的binary資料用base64解碼預設可能會有padding的問題，所以另外弄了一個function補齊padding。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess, os, json, itertools, sys</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> cStringIO <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter, ImageDraw</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_base64</span><span class="params">(data)</span>:</span></span><br><span class="line">    missing_padding = len(data) % <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> missing_padding != <span class="number">0</span>:</span><br><span class="line">        data += <span class="string">b'='</span>* (<span class="number">4</span> - missing_padding)</span><br><span class="line">    <span class="keyword">return</span> b64decode(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exiftool</span><span class="params">(cmd)</span>:</span></span><br><span class="line">    process = subprocess.Popen(<span class="string">"exiftool "</span>+cmd, stdout=subprocess.PIPE, shell=<span class="keyword">True</span>)</span><br><span class="line">    process_data = process.stdout.read()</span><br><span class="line">    process.kill()</span><br><span class="line">    <span class="keyword">return</span> process_data.strip()</span><br><span class="line"></span><br><span class="line">output_dir = sys.argv[<span class="number">1</span>] + <span class="string">"output"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">    os.makedirs(output_dir)</span><br><span class="line"></span><br><span class="line">jpg_list = sys.argv[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, oi <span class="keyword">in</span> enumerate(jpg_list):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"====== Start Processing &#123;0&#125; (&#123;1&#125;/&#123;2&#125;) ======"</span>.format(oi, idx+<span class="number">1</span>, len(jpg_list))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Get Image Information</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Fetch Image Information ... "</span></span><br><span class="line">    meta = json.loads(exiftool(<span class="string">"-G -j -sort &#123;0&#125;"</span>.format(oi)).decode(<span class="string">"utf-8"</span>).rstrip(<span class="string">"\r\n"</span>))[<span class="number">0</span>]</span><br><span class="line">    i_w = int(meta[<span class="string">u"XMP:FullPanoWidthPixels"</span>])</span><br><span class="line">    i_h = int(i_w/<span class="number">2</span>)</span><br><span class="line">    c_h = int(meta[<span class="string">u"XMP:CroppedAreaImageHeightPixels"</span>])</span><br><span class="line">    c_t = int(meta[<span class="string">u"XMP:CroppedAreaTopPixels"</span>])</span><br><span class="line">    c_b = i_h-c_h-c_t</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Extract Right Eye Image</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Extract Right Eye Image ... "</span></span><br><span class="line">    r_data = exiftool(<span class="string">"&#123;0&#125; -XMP-GImage:Data -b"</span>.format(oi))</span><br><span class="line">    ri = StringIO(decode_base64(r_data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Image Setting</span></span><br><span class="line">    lm = Image.open(oi)</span><br><span class="line">    rm = Image.open(ri)</span><br><span class="line">    main = Image.new(<span class="string">"RGB"</span>, (i_w, i_h*<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    im_list = []</span><br></pre></td></tr></table></figure></p><h1 id="圖像處理"><a href="#圖像處理" class="headerlink" title="圖像處理"></a>圖像處理</h1><p>接下來就是pillow的圖像處理部分，這邊是根據裁切的上下高度，去依比例將原有圖像分割兩塊，並垂直翻轉後放在原始圖像上下兩端延伸，再上一層模糊濾鏡。<br>在此之前先做了一個mask，稍微羽化邊緣，去當作前段所述的合成圖像跟原始圖像疊加的遮罩。<br>左右眼批次做完上述動作後合在一起，便完成所有步驟。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Create Alpha Mask for Image Overlay    </span></span><br><span class="line">    mask = Image.new(<span class="string">"L"</span>, (i_w, i_h))</span><br><span class="line">    mask_draw = ImageDraw.Draw(mask)</span><br><span class="line">    mask_draw.rectangle([<span class="number">0</span>, <span class="number">0</span>, i_w, c_t], <span class="number">255</span>)</span><br><span class="line">    mask_draw.rectangle([<span class="number">0</span>, c_t+c_h, i_w, i_h], <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">del</span> mask_draw</span><br><span class="line">    mask = mask.filter(ImageFilter.GaussianBlur(<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Image Process    </span></span><br><span class="line">    <span class="keyword">for</span> pic, eye <span class="keyword">in</span> itertools.izip([lm, rm], [<span class="string">"Left"</span>, <span class="string">"Right"</span>]):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Post-Processing &#123;0&#125; Eye Image ... "</span>.format(eye)</span><br><span class="line">        pic_t = pic.copy().crop((<span class="number">0</span>, <span class="number">0</span>, i_w, c_t/float(c_t+c_b)*c_h)).transpose(Image.FLIP_TOP_BOTTOM).resize((i_w, c_t))</span><br><span class="line">        pic_d = pic.copy().crop((<span class="number">0</span>, c_t/float(c_t+c_b)*c_h, i_w, c_h)).transpose(Image.FLIP_TOP_BOTTOM).resize((i_w, c_b))</span><br><span class="line">        pic_canvas = Image.new(<span class="string">"RGB"</span>, (i_w, i_h))</span><br><span class="line">        pic_canvas.paste(pic_t, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        pic_canvas.paste(pic, (<span class="number">0</span>, c_t))</span><br><span class="line">        pic_canvas.paste(pic_d, (<span class="number">0</span>, c_t+c_h))  </span><br><span class="line">        pic_overlay = pic_canvas.copy().filter(ImageFilter.GaussianBlur(<span class="number">100</span>))</span><br><span class="line">        pic_canvas.paste(pic_overlay, (<span class="number">0</span>, <span class="number">0</span>), mask)</span><br><span class="line">        im_list.append(pic_canvas)</span><br><span class="line">        <span class="keyword">for</span> im <span class="keyword">in</span> [pic, pic_t, pic_d, pic_overlay]:</span><br><span class="line">            im.close()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="comment">#Composite and Output</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Finalize Composition ... "</span></span><br><span class="line">    main.paste(im_list[<span class="number">0</span>], (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    main.paste(im_list[<span class="number">1</span>], (<span class="number">0</span>, i_h))</span><br><span class="line">    main.save(output_dir + <span class="string">"/"</span> + os.path.basename(oi))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> im <span class="keyword">in</span> ([mask, main, lm, rm] + im_list):</span><br><span class="line">        im.close()</span><br><span class="line">    ri.truncate(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Finish!!"</span></span><br></pre></td></tr></table></figure></p><img src="/cardboard-camera-htc-vive/01.jpg"><p>接下來就可以戴上 HTC Vive 或 Oculus Rift 使用程式觀看(上面影片所使用的是Virtual Desktop)。</p><p>要更進階的話，其實可以針對所有圖檔以及左右眼的圖像處理做threading，加快處理速度(PIL真的很慢)。另外exiftool在處理十張照片左右偶爾會出現memory leak的問題，目前還沒找到解決方法，不過就從斷點繼續轉就好，不太礙事。</p><a href="/cardboard-camera-htc-vive/source.zip" title="附上原始檔連結">附上原始檔連結</a>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//player.vimeo.com/video/192793926&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;Google 在 Android/iOS 雙平台推出的 Cardboard Camera，算是目前看過效果最好的360立體照片軟體之一，而且拍攝極其方便簡單，就可以產生出約10000像素寬的高解析立體照片。&lt;br&gt;問題是，這照片只能在手機自己的APP看，從手機的相簿或者傳到電腦上，會發現只有一張照片。&lt;/p&gt;
&lt;p&gt;這問題在 &lt;a href=&quot;http://vectorcult.com/2015/12/extracting-the-audio-stereo-pair-from-cardboard-camera-3d-panoramic-images/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vector Cult VR&lt;/a&gt; 的文章 有很詳盡的解釋。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://mur.elii.io/tags/python/"/>
    
      <category term="vr" scheme="https://mur.elii.io/tags/vr/"/>
    
      <category term="vive" scheme="https://mur.elii.io/tags/vive/"/>
    
      <category term="camera" scheme="https://mur.elii.io/tags/camera/"/>
    
  </entry>
  
  <entry>
    <title>Particle Flow飛彈尾煙Maxscript練習</title>
    <link href="https://mur.elii.io/particleflow-maxscript-missle/"/>
    <id>https://mur.elii.io/particleflow-maxscript-missle/</id>
    <published>2016-09-12T11:32:00.000Z</published>
    <updated>2018-04-21T18:05:15.000Z</updated>
    
    <content type="html"><![CDATA[<video src="/particleflow-maxscript-missle/cover.mp4" autoplay loop></video><p>接到一個任務，一個飛行器上面有八顆飛彈，總共會有四十幾台飛行器，已經都有手key的飛行器移動跟飛彈射出去的動畫(這也是個花時間的功夫阿)，而我需要做的是，要在這現成的場景上的每顆飛彈加上尾煙。</p><p>由於整個表現在畫面上其實所佔不大，尾煙沒有離鏡頭很近，於是決定採用類似遊戲或AE的方式用sprite搞定尾煙的呈現，不然四十幾台用模擬會重死。而因為場景在3ds max，決定就直接用particle flow來做，也當作一個particle flow上首次用maxscript的練習。</p><a id="more"></a><p>總體來說就是要做：<strong>偵測飛彈什麼時候發射，並針對發射路徑產生particle。</strong></p><p>由於有四十幾台，盡量還是找最快速最程序性的方式，不要用暴力來解決問題。</p><video src="/particleflow-maxscript-missle/01.mp4" autoplay loop></video><p>在這邊做了一個示範場景，用幽浮當飛行器，並簡化數量。</p><p>然後也不會將整個流程跑到算圖，注重在寫maxscript的部分。</p><h1 id="場景前製準備"><a href="#場景前製準備" class="headerlink" title="場景前製準備"></a>場景前製準備</h1><p>在前端user製作時，已經提醒命名方式，並將飛彈的pivot都設在尾端，階層如下圖：<br><img src="/particleflow-maxscript-missle/02.png"><br>我要做的是，為每個飛彈製作兩個dummy，一個link在飛彈上(叫fly)，一個link在幽浮上(叫stay)，當兩個dummy偵測彼此距離分開了，就等於飛彈發射了，相當不吃效能且輕鬆簡單。</p><p>那第一步就是要創建dummy，因為有四十幾台，不可能一個一個來，於是用簡單的maxscript來自動作業：<br><figure class="highlight maxscript"><table><tr><td class="code"><pre><span class="line"><span class="identifier">missile_list</span> = <span class="pathname">$*missile*</span> <span class="identifier"><span class="keyword">as</span></span> <span class="identifier">array</span> <span class="comment">--將飛彈蒐集成序列</span></span><br><span class="line"><span class="identifier"><span class="keyword">for</span></span> <span class="identifier">i</span> = <span class="number">1</span> <span class="identifier"><span class="keyword">to</span></span> <span class="identifier">missile_list</span>.<span class="identifier">count</span> <span class="identifier"><span class="keyword">do</span></span>( <span class="comment">--重複飛彈數量次數的循環</span></span><br><span class="line"> <span class="comment">--指定這次循環的飛彈</span></span><br><span class="line"> <span class="identifier">missile</span> = <span class="identifier">missile_list</span>[<span class="identifier">i</span>]</span><br><span class="line"> </span><br><span class="line"> <span class="comment">--創造dummy綁在飛彈上，名稱後面加上_fly</span></span><br><span class="line"> <span class="identifier">dmy_fly</span> = <span class="identifier">dummy</span> <span class="identifier">transform</span>:<span class="identifier">missile</span>.<span class="identifier">transform</span> <span class="identifier">name</span>:(<span class="identifier">missile</span>.<span class="identifier">name</span>+<span class="string">"_fly"</span>)</span><br><span class="line"> <span class="identifier">dmy_fly</span>.<span class="identifier">parent</span> = <span class="identifier">missile</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">--找到飛彈所屬的ufo，然後複製剛剛的dummy改綁在ufo上，名稱後面加上_stay</span></span><br><span class="line"> <span class="identifier">ufo</span> = <span class="identifier">missile</span>.<span class="identifier">parent</span></span><br><span class="line"> <span class="identifier">dmy_stay</span> = <span class="identifier">copy</span> <span class="identifier">dmy_fly</span></span><br><span class="line"> <span class="identifier">dmy_stay</span>.<span class="identifier">name</span> = <span class="identifier">missile</span>.<span class="identifier">name</span>+<span class="string">"_stay"</span></span><br><span class="line"> <span class="identifier">dmy_stay</span>.<span class="identifier">parent</span> = <span class="identifier">ufo</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>要注意的是，執行這個script的時候必須是在所有飛彈都還沒離開幽浮之前的影格數。<br>而且因為現在場景簡單，飛彈蒐集的方式很隨便，就只是找名字有missile就抓起來，如果場景複雜可能要多點條件篩選。</p><p>script執行後，便會得到下面的畫面：<br><video src="/particleflow-maxscript-missle/03.mp4" autoplay loop></video></p><p>在explorer看到會是這樣：<br><img src="/particleflow-maxscript-missle/04.png"></p><p>接下來就是主菜particle flow的部分。</p><h1 id="創建粒子"><a href="#創建粒子" class="headerlink" title="創建粒子"></a>創建粒子</h1><img src="/particleflow-maxscript-missle/05.png"><p>創建一個Empty Flow，並新增一個Birth Script，要用來為每個飛彈生成一個particle。</p><p>內容如下：<br><figure class="highlight maxscript"><table><tr><td class="code"><pre><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">ChannelsUsed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span></span><br><span class="line">(</span><br><span class="line"> <span class="comment">--使用integer來儲存飛彈列表的序號</span></span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">useInteger</span> = <span class="identifier"><span class="predefined-global">true</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">Init</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span> </span><br><span class="line">(</span><br><span class="line"> <span class="comment">--比較名字的公式</span></span><br><span class="line"> <span class="identifier"><span class="keyword">fn</span></span> <span class="identifier">compareNames</span> <span class="identifier">str1</span> <span class="identifier">str2</span> = <span class="identifier">stricmp</span> <span class="identifier">str1</span>.<span class="identifier">name</span> <span class="identifier">str2</span>.<span class="identifier">name</span></span><br><span class="line"></span><br><span class="line"> <span class="identifier"><span class="keyword">global</span></span> <span class="identifier">fly_list</span> = <span class="pathname">$ufo*fly*</span> <span class="identifier"><span class="keyword">as</span></span> <span class="identifier">array</span> <span class="comment">--蒐集全部的fly Dummy成一個列表，註冊為global變數</span></span><br><span class="line"> <span class="identifier"><span class="keyword">global</span></span> <span class="identifier">stay_list</span> = <span class="pathname">$ufo*stay*</span> <span class="identifier"><span class="keyword">as</span></span> <span class="identifier">array</span>  <span class="comment">--蒐集全部的stay Dummy成一個列表，註冊為global變數</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">--依照名稱排列好，以防萬一</span></span><br><span class="line"> <span class="identifier">qSort</span> <span class="identifier">fly_list</span> <span class="identifier">compareNames</span>  </span><br><span class="line"> <span class="identifier">qSort</span> <span class="identifier">stay_list</span> <span class="identifier">compareNames</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">Proceed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span> </span><br><span class="line">( </span><br><span class="line"> <span class="identifier">t</span> = <span class="identifier">pCont</span>.<span class="identifier">getTimeStart</span>() </span><br><span class="line"> <span class="identifier"><span class="keyword">if</span></span> <span class="identifier">t</span> == <span class="identifier"><span class="system-global">animationrange</span></span>.<span class="identifier">start</span> <span class="identifier"><span class="keyword">then</span></span>(  <span class="comment">--判斷是動畫第一格才會生成particle</span></span><br><span class="line">  <span class="identifier">pCont</span>.<span class="identifier">AddParticles</span> <span class="identifier">fly_list</span>.<span class="identifier">count</span>  <span class="comment">--生成跟列表一樣數量的particle</span></span><br><span class="line">  <span class="identifier"><span class="keyword">for</span></span> <span class="identifier">i</span> = <span class="number">1</span> <span class="identifier"><span class="keyword">to</span></span> <span class="identifier">pCont</span>.<span class="identifier">numParticles</span>() <span class="identifier"><span class="keyword">do</span></span>(</span><br><span class="line">   <span class="comment">--將列表序號儲存在integer通道</span></span><br><span class="line">   <span class="identifier">pCont</span>.<span class="identifier">particleIndex</span> = <span class="identifier">i</span></span><br><span class="line">   <span class="identifier">pCont</span>.<span class="identifier">particleInteger</span> = <span class="identifier">i</span></span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>依這範例來說，在init初始化時產生跟著飛彈動的fly列表，以及原地跟著幽浮的stay列表。<br>然後在動畫第一格生成六顆particle，<strong>每一顆particle都有一個integer編號代表他是對應fly列表跟stay列表的第幾個，之後所產生的particle都會給-1，來跟這六個母體分開</strong>，這算是最重要的核心想法。</p><h1 id="黏在飛彈上"><a href="#黏在飛彈上" class="headerlink" title="黏在飛彈上"></a>黏在飛彈上</h1><p>生成結束後，我們要將particle黏在飛彈身上，才可以去偵測什麼時候離開stay的dummy。</p><img src="/particleflow-maxscript-missle/06.png"><p>於是新增一個script operator，去做黏在飛彈上的動作：<br><figure class="highlight maxscript"><table><tr><td class="code"><pre><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">ChannelsUsed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span></span><br><span class="line">(</span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">usePosition</span> = <span class="identifier"><span class="predefined-global">true</span></span> <span class="comment">--用position設定現在位置</span></span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">useInteger</span> = <span class="identifier"><span class="predefined-global">true</span></span>  <span class="comment">--用integer對應列表編號</span></span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">useVector</span> = <span class="identifier"><span class="predefined-global">true</span></span>  <span class="comment">--用vector儲存上一格位置</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">Proceed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span> </span><br><span class="line">(</span><br><span class="line"> <span class="identifier">count</span> = <span class="identifier">pCont</span>.<span class="identifier">numParticles</span>()</span><br><span class="line"> <span class="identifier"><span class="keyword">for</span></span> <span class="identifier">i</span> = <span class="number">1</span> <span class="identifier"><span class="keyword">to</span></span> <span class="identifier">count</span> <span class="identifier"><span class="keyword">do</span></span>( <span class="comment">--針對每個particle做循環</span></span><br><span class="line">  <span class="identifier">pCont</span>.<span class="identifier">particleIndex</span> =  <span class="identifier">i</span></span><br><span class="line">  <span class="identifier"><span class="keyword">if</span></span> <span class="identifier">pCont</span>.<span class="identifier">particleInteger</span> != <span class="number">-1</span> <span class="identifier"><span class="keyword">then</span></span>( <span class="comment">--如果integer不等於-1時再去設定位置</span></span><br><span class="line">   <span class="identifier">id</span> = <span class="identifier">pCont</span>.<span class="identifier">particleInteger</span></span><br><span class="line">   <span class="identifier">pCont</span>.<span class="identifier">particleVector</span> = <span class="identifier">pCont</span>.<span class="identifier">particleTM</span>[<span class="number">4</span>] <span class="comment">--vector先儲存現在位置</span></span><br><span class="line">   <span class="identifier">pCont</span>.<span class="identifier">particlePosition</span> = <span class="identifier">fly_list</span>[<span class="identifier">id</span>].<span class="identifier">pos</span>  <span class="comment">--Position再去設定成對應fly列表編號的dummy位置</span></span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>每一格particle都會去移動到fly列表對應的dummy的位置，而fly列表就是飛彈們的位置，另外開啟了一個vector通道去紀錄上一格的位置，這跟偵測integer是否為-1都是之後要用的。</p><h1 id="偵測飛彈發射時機"><a href="#偵測飛彈發射時機" class="headerlink" title="偵測飛彈發射時機"></a>偵測飛彈發射時機</h1><p>現在，particle會跟著飛彈移動了，然後也有與之對應的stay dummy資料，就可以偵測哪一格particle會跟stay dummy分開，就是飛彈發射的時候，然後送入到下一個事件。</p><p>所以接下來，我們要新增Script Test。<br><img src="/particleflow-maxscript-missle/07.png"><br><figure class="highlight maxscript"><table><tr><td class="code"><pre><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">ChannelsUsed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span></span><br><span class="line">(</span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">usePosition</span> = <span class="identifier"><span class="predefined-global">true</span></span> <span class="comment">--用Position通道偵測位置</span></span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">useInteger</span> = <span class="identifier"><span class="predefined-global">true</span></span>  <span class="comment">--用Integer通道找stay列表對應的dummy</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">Proceed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span> </span><br><span class="line">(</span><br><span class="line"> <span class="identifier">count</span> = <span class="identifier">pCont</span>.<span class="identifier">NumParticles</span>()</span><br><span class="line"> <span class="identifier"><span class="keyword">for</span></span> <span class="identifier">i</span> <span class="identifier"><span class="keyword">in</span></span> <span class="number">1</span> <span class="identifier"><span class="keyword">to</span></span> <span class="identifier">count</span> <span class="identifier"><span class="keyword">do</span></span></span><br><span class="line"> (</span><br><span class="line">  <span class="identifier">pCont</span>.<span class="identifier">particleIndex</span> = <span class="identifier">i</span></span><br><span class="line">  <span class="identifier">id</span> = <span class="identifier">pCont</span>.<span class="identifier">particleInteger</span></span><br><span class="line">  <span class="comment">--以上是每顆particle循環所需的前置，而下面是判斷particle的位置大於5時，將particle通過測試</span></span><br><span class="line">  <span class="identifier"><span class="keyword">if</span></span> <span class="identifier">distance</span> <span class="identifier">pCont</span>.<span class="identifier">particlePosition</span> <span class="identifier">stay_list</span>[<span class="identifier">id</span>].<span class="identifier">pos</span> &gt; <span class="number">5</span> <span class="identifier"><span class="keyword">then</span></span></span><br><span class="line">  (</span><br><span class="line">   <span class="identifier">pCont</span>.<span class="identifier">particleTestStatus</span> = <span class="identifier"><span class="predefined-global">true</span></span></span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>這邊比較簡單，只是要判斷距離並送到下一個事件，而距離5這個值其實可以設定成變數，會更方便修改。</p><p>測試通過後，便要送到下一個事件。</p><h1 id="繼續-黏在飛彈上"><a href="#繼續-黏在飛彈上" class="headerlink" title="繼續 黏在飛彈上"></a>繼續 黏在飛彈上</h1><p>而下一個事件呢，這些飛彈所屬的particle還是要綁在飛彈上，所以複製(instance)一份剛剛黏在飛彈上的語法，貼在新事件上。<br><img src="/particleflow-maxscript-missle/08.png"></p><p>這時候如果沒有出錯的話，播放時應該會如下方動畫這樣。</p><video src="/particleflow-maxscript-missle/08_.mp4" autoplay loop></video><p>注意看每個飛彈尾端particle id號碼顏色，起初都是紫色，只在發射進入下一個事件後變成黃色。</p><h1 id="產生尾煙particle"><a href="#產生尾煙particle" class="headerlink" title="產生尾煙particle"></a>產生尾煙particle</h1><p>或許你會想說，接續只要用內建的spawn產生尾巴就可以了。但其實不能這麼做，因為spawn依靠的值是速度。前面雖然都有設定每格該去的位置，但速度沒有設定到。</p><p>那接下來要設定速度去做spawn嗎？</p><p>不，這不是最好的做法，原始場景有四十幾個飛行器，飛彈飛行的速率、路徑的彎曲程度、<strong>每格採樣次數</strong>都會大幅影響生成的效率跟品質。</p><p>所以我們就自己做一個改良版的spawn吧！不會被這些因素所影響，路徑走多少，就生成固定數量的particle。<br><img src="/particleflow-maxscript-missle/09.png"></p><p>一樣新增一個script operator，這邊可能比較複雜。<br><figure class="highlight maxscript"><table><tr><td class="code"><pre><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">ChannelsUsed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span></span><br><span class="line">(</span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">usePosition</span> = <span class="identifier"><span class="predefined-global">true</span></span>  <span class="comment">--使用現在位置</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">--這邊的integer不是拿來對應列表，而是針對隨路徑生成的particle設定-1，好隔開跟原先particle的差異</span></span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">useInteger</span> = <span class="identifier"><span class="predefined-global">true</span></span>  </span><br><span class="line"></span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">useVector</span> = <span class="identifier"><span class="predefined-global">true</span></span>  <span class="comment">--之前設定的上一格位置就是這邊要使用的</span></span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">useFloat</span> = <span class="identifier"><span class="predefined-global">true</span></span>  <span class="comment">--這個流程最重要的核心浮點數，用來計算下一次要生成particle的剩餘距離</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">Proceed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span> </span><br><span class="line">(</span><br><span class="line"> <span class="identifier">count</span> = <span class="identifier">pCont</span>.<span class="identifier">NumParticles</span>()</span><br><span class="line"> <span class="identifier">step</span> = <span class="number">5</span>  <span class="comment">--這個step是用來定義，每多少距離要生成一次particle</span></span><br><span class="line"> <span class="identifier"><span class="keyword">for</span></span> <span class="identifier">n</span> = <span class="number">1</span> <span class="identifier"><span class="keyword">to</span></span> <span class="identifier">count</span> <span class="identifier"><span class="keyword">do</span></span>(  <span class="comment">--先針對現有particle做循環</span></span><br><span class="line">  <span class="identifier">pCont</span>.<span class="identifier">particleIndex</span> =  <span class="identifier">n</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">--要先篩選掉integer是-1的particle，也就是黏在飛彈上的particle才能參與生成尾煙的流程(避免有些尾煙particle還沒被送到下一個事件)</span></span><br><span class="line">  <span class="identifier"><span class="keyword">if</span></span> <span class="identifier">pCont</span>.<span class="identifier">particleInteger</span> != <span class="number">-1</span> <span class="identifier"><span class="keyword">then</span></span>(</span><br><span class="line"></span><br><span class="line">   <span class="comment">--取出上一格位置到這一格位置的資訊，要在這兩個位置之間產生particle</span></span><br><span class="line">   <span class="identifier">origin_pos</span> = <span class="identifier">pCont</span>.<span class="identifier">particleVector</span></span><br><span class="line">   <span class="identifier">target_pos</span> = <span class="identifier">pCont</span>.<span class="identifier">particlePosition</span></span><br><span class="line">   <span class="identifier">toward_vector</span> = <span class="identifier">target_pos</span>-<span class="identifier">origin_pos</span></span><br><span class="line">   <span class="identifier">toward_distance</span> = <span class="identifier">distance</span> <span class="identifier">target_pos</span> <span class="identifier">origin_pos</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">--取得剩餘距離，如果沒有宣告過就給0</span></span><br><span class="line">   <span class="identifier">rest_value</span> = <span class="identifier">pCont</span>.<span class="identifier">particleFloat</span></span><br><span class="line">   <span class="identifier"><span class="keyword">if</span></span> <span class="identifier">rest_value</span> == <span class="identifier"><span class="predefined-global">undefined</span></span> <span class="identifier"><span class="keyword">then</span></span> <span class="identifier">rest_value</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">--判斷有沒有移動，沒移動的話接下來這些程式都不執行</span></span><br><span class="line">   <span class="identifier"><span class="keyword">if</span></span> <span class="identifier">toward_distance</span> &gt; <span class="number">0</span> <span class="identifier"><span class="keyword">then</span></span>(</span><br><span class="line"></span><br><span class="line">    <span class="comment">--有移動! 那移動的距離間隔夠產生particle嗎?</span></span><br><span class="line">    <span class="identifier"><span class="keyword">if</span></span> <span class="identifier">rest_value</span> + <span class="identifier">step</span> &lt; <span class="identifier">toward_distance</span> <span class="identifier"><span class="keyword">then</span></span>(</span><br><span class="line">     <span class="comment">--夠產生particle的狀況，去做一個增加step的循環，直到移動的距離再也不能產生particle</span></span><br><span class="line">     <span class="identifier"><span class="keyword">local</span></span> <span class="identifier">final_i</span></span><br><span class="line">     <span class="identifier"><span class="keyword">for</span></span> <span class="identifier">i</span> = <span class="identifier">rest_value</span>+<span class="identifier">step</span> <span class="identifier"><span class="keyword">to</span></span> <span class="identifier">toward_distance</span> <span class="identifier"><span class="keyword">by</span></span> <span class="identifier">step</span> <span class="identifier"><span class="keyword">do</span></span>(</span><br><span class="line">      <span class="identifier">pCont</span>.<span class="identifier">AddParticle</span>() <span class="comment">--產生particle</span></span><br><span class="line">      <span class="identifier">pCont</span>.<span class="identifier">particleIndex</span> = <span class="identifier">pCont</span>.<span class="identifier">NumParticles</span>()  <span class="comment">--將接下來的狀況主角變成這個新生particle</span></span><br><span class="line">      <span class="identifier">new_pos</span> = <span class="identifier">origin_pos</span> + <span class="identifier">i</span>/<span class="identifier">toward_distance</span> * <span class="identifier">toward_vector</span>  <span class="comment">--用現在距離跟目的距離算出要產生particle的位置</span></span><br><span class="line">      <span class="identifier">pCont</span>.<span class="identifier">particlePosition</span> = <span class="identifier">new_pos</span></span><br><span class="line">      <span class="identifier">pCont</span>.<span class="identifier">particleInteger</span> = <span class="number">-1</span></span><br><span class="line">      <span class="identifier">final_i</span> = <span class="identifier">i</span>  <span class="comment">--取得總共行進有增加particle的距離</span></span><br><span class="line">     )</span><br><span class="line">     <span class="identifier">pCont</span>.<span class="identifier">particleIndex</span> =  <span class="identifier">n</span>  <span class="comment">--將主角喚回母particle</span></span><br><span class="line">     <span class="identifier">pCont</span>.<span class="identifier">particleFloat</span> = <span class="identifier">toward_distance</span> - <span class="identifier">final_i</span>  <span class="comment">--總結最後的剩餘距離</span></span><br><span class="line">    )<span class="identifier"><span class="keyword">else</span></span>(</span><br><span class="line">     <span class="comment">--不夠產生particle的狀況，將剩餘距離除去現在這一段，下一格繼續努力</span></span><br><span class="line">     <span class="identifier">pCont</span>.<span class="identifier">particleFloat</span> = <span class="identifier">rest_value</span> - <span class="identifier">toward_distance</span></span><br><span class="line">    )</span><br><span class="line">   )</span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>看起來很繁瑣，但簡單來說，就是先設定了每多少間隔就產生particle，然後拿現在位置跟上次位置的行走距離除以間隔去判斷要生成多少particle，再去處理一些細節眉角，就可以得到一個沿運動路徑均衡產生particle的operator。</p><h1 id="判斷送到尾煙事件"><a href="#判斷送到尾煙事件" class="headerlink" title="判斷送到尾煙事件"></a>判斷送到尾煙事件</h1><p>接著，要篩選出這些產生的particle給送到下一個，也是最後一個要算成尾煙sprite的事件。<br><img src="/particleflow-maxscript-missle/10.png"><br><figure class="highlight maxscript"><table><tr><td class="code"><pre><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">ChannelsUsed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span></span><br><span class="line">(</span><br><span class="line"> <span class="identifier">pCont</span>.<span class="identifier">useInteger</span> = <span class="identifier"><span class="predefined-global">true</span></span>  <span class="comment">--採用integer通道判斷</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">Init</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span> </span><br><span class="line">(</span><br><span class="line"> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="identifier"><span class="keyword">on</span></span> <span class="identifier">Proceed</span> <span class="identifier">pCont</span> <span class="identifier"><span class="keyword">do</span></span> </span><br><span class="line">(</span><br><span class="line"> <span class="identifier">count</span> = <span class="identifier">pCont</span>.<span class="identifier">NumParticles</span>()</span><br><span class="line"> <span class="identifier"><span class="keyword">for</span></span> <span class="identifier">i</span> <span class="identifier"><span class="keyword">in</span></span> <span class="number">1</span> <span class="identifier"><span class="keyword">to</span></span> <span class="identifier">count</span> <span class="identifier"><span class="keyword">do</span></span></span><br><span class="line"> (</span><br><span class="line">  <span class="identifier">pCont</span>.<span class="identifier">particleIndex</span> = <span class="identifier">i</span></span><br><span class="line">  <span class="identifier"><span class="keyword">if</span></span> <span class="identifier">pCont</span>.<span class="identifier">particleInteger</span> == <span class="number">-1</span> <span class="identifier"><span class="keyword">then</span></span>  <span class="comment">--如果integer通道等於-1就送出去</span></span><br><span class="line">  (</span><br><span class="line">   <span class="identifier">pCont</span>.<span class="identifier">particleTestStatus</span> = <span class="identifier"><span class="predefined-global">true</span></span></span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>因為最一開始母particle都有指定編號，對應飛彈列表，而後來隨距離產生的particle，都設成-1，所以可以很簡單的分類，並送到下一個事件(前面做黏在飛彈上的script有-1的先行判斷也是為此)。</p><h1 id="尾煙屬性設定"><a href="#尾煙屬性設定" class="headerlink" title="尾煙屬性設定"></a>尾煙屬性設定</h1><p>最後一個事件是做sprite渲染，就是用shape facing去對準攝影機，用material dynamic去播sprite動畫，然後用些spin、speed等參數調整動態，這就不在本篇討論範圍，在此用個簡單的預設菱形取代。<br><img src="/particleflow-maxscript-missle/11.png"></p><p>到這邊就算完成了，結果如下：<br><video src="/particleflow-maxscript-missle/12.mp4" autoplay loop></video></p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>在原始專案，七百多格，四十幾台飛行器，每台飛行器八顆飛彈，也是五分鐘就模擬完，負荷相當輕。</p><p>particle flow上的maxscript，說實話很難搞，邏輯跟houdini相當不同，效能差，bug也頗多，但首次練習是覺得滿新鮮有趣的，不過下次如果硬要在max做還是用TP吧！</p><p>另外有一個小瑕疵是，算圖時要先bake起來，不然有時候不會每格都去做計算，這可能是對particle flow的script不夠熟悉而有的錯誤，所以在專案製作時是先bake成xmesh。</p><p>或許會覺得說，bake成xmesh那age那些資訊不就跑掉了，但其實這些資訊都可以用mapping保留的。</p><img src="/particleflow-maxscript-missle/13.png"><p>像這邊我在最後加了一個mapping，去key U值紀錄每個particle在最後一個尾煙事件的時間，存在channel 2。</p><img src="/particleflow-maxscript-missle/14.png"><p>這樣之後的xmesh上材質時，就可以在透明度上一層gradient ramp(注意紅圈勾起的微調)，去控制隨著事件時間漸淡，甚至也可以應用在其他地方，做成離火箭尾端近的地方有橘紅色火光之類。</p>]]></content>
    
    <summary type="html">
    
      &lt;video src=&quot;/particleflow-maxscript-missle/cover.mp4&quot; autoplay loop&gt;&lt;/video&gt;
&lt;p&gt;接到一個任務，一個飛行器上面有八顆飛彈，總共會有四十幾台飛行器，已經都有手key的飛行器移動跟飛彈射出去的動畫(這也是個花時間的功夫阿)，而我需要做的是，要在這現成的場景上的每顆飛彈加上尾煙。&lt;/p&gt;
&lt;p&gt;由於整個表現在畫面上其實所佔不大，尾煙沒有離鏡頭很近，於是決定採用類似遊戲或AE的方式用sprite搞定尾煙的呈現，不然四十幾台用模擬會重死。而因為場景在3ds max，決定就直接用particle flow來做，也當作一個particle flow上首次用maxscript的練習。&lt;/p&gt;
    
    </summary>
    
    
      <category term="3ds max" scheme="https://mur.elii.io/tags/3ds-max/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
      <category term="maxscript" scheme="https://mur.elii.io/tags/maxscript/"/>
    
      <category term="particle flow" scheme="https://mur.elii.io/tags/particle-flow/"/>
    
  </entry>
  
  <entry>
    <title>Houdini出Alembic給VrayProxy的資訊夾帶方法</title>
    <link href="https://mur.elii.io/houdini-alembic-vray-proxy/"/>
    <id>https://mur.elii.io/houdini-alembic-vray-proxy/</id>
    <published>2016-09-10T10:51:47.000Z</published>
    <updated>2018-04-20T23:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/houdini-alembic-vray-proxy/01.jpg"><p>以往我在做houdini出particle到max的流程中，是用prt格式比較多，但近期發現vray proxy來讀alembic是很不錯的方式。</p><p>max內建讀取alembic效能很差，而exocortex的外掛是有較多相容性，但效能一樣不佳。vray proxy卻是一反前二者有著極佳的讀取速度，也有viewport減面的優化功能，在不用做二次編輯之下，vray proxy相信是目前max讀取abc的首選。</p><p>vray proxy可以讀取的資訊相當豐富，這篇就概括說明一下，houdini的資訊要怎麼帶到vray proxy。<br><a id="more"></a></p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>以下主要側重在houdini的particle出abc給vray proxy的部分，這部分在官方document幾乎沒有資料，在研究了alembic的格式結構、論壇討論以及實際測試後，整理成以下的方法：</p><img src="/houdini-alembic-vray-proxy/02.png"><p>這邊以一個往斜上方的點當作particle資訊夾帶範例，圖上數字為自創的width屬性。</p><h1 id="設定屬性"><a href="#設定屬性" class="headerlink" title="設定屬性"></a>設定屬性</h1><img src="/houdini-alembic-vray-proxy/03.png"><p>創了一個斜線之後，只留下點的部分，並用vex給予這些設定。<br>我設定了三個屬性：width、Cd、mask：</p><ul><li>width即是vray proxy算圖時的particle大小，也就是houdini的<strong>pscale</strong>。</li><li>Cd是顏色，但其實出給vray proxy不用特地要叫Cd，<strong>只要你有設定屬性，vray proxy都可以讀</strong>。</li><li>最後我設定了一個mask，這個是要來跟Cd做<strong>對照</strong></li></ul><p>要<strong>對照</strong>什麼呢？</p><p>你可以看到最後一行特地設定了屬性的type，把mask指定為vector屬性，其實在houdini裡基本上沒必要做這件事，當打下v@就已經知道是vector，這邊的屬性可以說是設定給alembic看，並可以順利給予vray proxy讀取的，不然vray proxy只會將mask這屬性視作單一浮點數。</p><p>那為什麼只設定了mask沒設定Cd？那是因為houdini本身就有內建幾個對應屬性類別，像v、Cd這些常用屬性都是，所以不用特別做設定。<br>這也代表說，你設定向量的屬性type其實用vector或color都可以。</p><h1 id="匯入Alembic"><a href="#匯入Alembic" class="headerlink" title="匯入Alembic"></a>匯入Alembic</h1><img src="/houdini-alembic-vray-proxy/04.png"><p>接著到max裡讀取houdini輸出的abc，注意要將vray proxy的X軸旋轉90度，縮放100倍，才會是正確大小與軸向。</p><p>如果方才有輸出width屬性，這邊就會自動對應了，而vray proxy本身的介面也有一個width總控制去相乘，像剛剛如果有縮放一百倍，這邊就要將width設成0.01。</p><img src="/houdini-alembic-vray-proxy/05.png"><p>而其他屬性資訊部分，全都含在vertex color的map channel，如果有上vertex color貼圖，可以看到channel name這邊會顯示全部屬性名稱，如果是單一浮點數屬性，名字會像<strong>r_mask</strong>這樣有一個<strong>r_</strong>的起頭。</p><h1 id="試算"><a href="#試算" class="headerlink" title="試算"></a>試算</h1><img src="/houdini-alembic-vray-proxy/06.png"><p>採vray light mtl並將顏色部分貼上vertex color，試算可以看到資訊完全正確。</p><img src="/houdini-alembic-vray-proxy/07.png"><p>試算時，也順便增加了一個ExtraTex pass夾帶mask資訊，也是正確無誤。<br>因此可以延伸想說，其實不只particle，連一般物體都可以夾帶許多屬性用vray proxy的方式到vray這邊算，讓出圖跟後期合成增添許多彈性。</p><p>雖然vray算particle的速度遠遠不及krakatoa，但在專案整合，場景整理上，如果能一起用vray算圖也是很方便。尤其最近公司很多VR專案，就不用去在乎場景matte或者VR攝影機。</p><h1 id="發光材質"><a href="#發光材質" class="headerlink" title="發光材質"></a>發光材質</h1><img src="/houdini-alembic-vray-proxy/08.png"><p>krakatoa的additive渲染效果，其實vray也可以達到，上圖是一般預設材質的particle。</p><img src="/houdini-alembic-vray-proxy/09.png"><p>材質用vraylight，opacity給上一張非常暗的vraycolor，然後去調整color顏色、強度跟opacity的濃淡，就可以達到additive的效果。<br>這邊的材質參數是：顏色藍綠色，強度3來增加密集的亮度，opacity的vraycolor是0.05的灰質。<br>當然，這種方法出圖也會跟krakatoa的additive渲染一樣無法使用alpha。</p><h1 id="Material-ID"><a href="#Material-ID" class="headerlink" title="Material ID"></a>Material ID</h1><img src="/houdini-alembic-vray-proxy/10.png"><p>額外簡單說明material id的部分，其實就是用group去出成alembic的face set。</p><img src="/houdini-alembic-vray-proxy/11.png"><p>隨便用一個multi material。</p><img src="/houdini-alembic-vray-proxy/12.png"><p>基本上id順序應該是group的名稱順序。</p><h1 id="更新補充"><a href="#更新補充" class="headerlink" title="更新補充"></a>更新補充</h1><p>忘記提motion blur這塊，一樣用v去帶，不過有兩個小bug。</p><ul><li>cache最開始不能是空的，也就是第一格cache是要有particle存在的格數。</li><li>輸出單格abc無法應用vray內建的motion blur，但velocity pass會有。一定要輸出多格的才會有motion blur。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/houdini-alembic-vray-proxy/01.jpg&quot;&gt;
&lt;p&gt;以往我在做houdini出particle到max的流程中，是用prt格式比較多，但近期發現vray proxy來讀alembic是很不錯的方式。&lt;/p&gt;
&lt;p&gt;max內建讀取alembic效能很差，而exocortex的外掛是有較多相容性，但效能一樣不佳。vray proxy卻是一反前二者有著極佳的讀取速度，也有viewport減面的優化功能，在不用做二次編輯之下，vray proxy相信是目前max讀取abc的首選。&lt;/p&gt;
&lt;p&gt;vray proxy可以讀取的資訊相當豐富，這篇就概括說明一下，houdini的資訊要怎麼帶到vray proxy。&lt;br&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
      <category term="alembic" scheme="https://mur.elii.io/tags/alembic/"/>
    
      <category term="vray" scheme="https://mur.elii.io/tags/vray/"/>
    
      <category term="shader" scheme="https://mur.elii.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>Houdini取出任意模型的截面線</title>
    <link href="https://mur.elii.io/houdini-slice-curve/"/>
    <id>https://mur.elii.io/houdini-slice-curve/</id>
    <published>2016-09-05T10:37:49.000Z</published>
    <updated>2018-04-21T18:08:25.000Z</updated>
    
    <content type="html"><![CDATA[<video src="/houdini-slice-curve/cover.mp4" autoplay loop></video><p>上一篇的截線是針對球型的，那如果是任意模型的截面呢？</p><p>或許會直覺想說，創造一個 grid，然後跟模型用 cookie 的方式選擇 crease 模式去取出來，但其實布林的方式限制很多(例如模型要封閉)，各種不穩定的因素，而且也比較需要計算效能。</p><p>在這邊使用的是以 clip 為主軸的方法，效能快，穩定，而且模型也不需要封閉。<br><a id="more"></a></p><h1 id="模型準備"><a href="#模型準備" class="headerlink" title="模型準備"></a>模型準備</h1><img src="/houdini-slice-curve/01.png"><p>使用的範例模型是 houdini 內建的豬頭，並開了幾個洞讓它變成開放式模型好做示範。</p><h1 id="流程概要"><a href="#流程概要" class="headerlink" title="流程概要"></a>流程概要</h1><img src="/houdini-slice-curve/02.png"><p>整個流程如圖：記下開放的 edges，clip 切割，再記一次開放的 edges (並撇除第一次記下的 edges)，用 polycut 刪除前者以外的模型，用繼承 clip 屬性的 grid 去清潔模型。</p><h1 id="group"><a href="#group" class="headerlink" title="group"></a>group</h1><img src="/houdini-slice-curve/03.png"><p>首先，先 group 既有的開放邊線，這邊取名作 initial_open_edge。</p><h1 id="clip"><a href="#clip" class="headerlink" title="clip"></a>clip</h1><img src="/houdini-slice-curve/04.png"><p>接著 clip 想取出的截面，任意數值方向無所謂。</p><h1 id="邊線群組"><a href="#邊線群組" class="headerlink" title="邊線群組"></a>邊線群組</h1><img src="/houdini-slice-curve/05.png"><p>這次再 group 一次開放邊線，並撇除前一次的 initial_open_edge，這樣就可以得到 clip 切割出的邊線群組，這邊取作 clip_edge。</p><h1 id="非邊線群組"><a href="#非邊線群組" class="headerlink" title="非邊線群組"></a>非邊線群組</h1><img src="/houdini-slice-curve/06.png"><p>將不是 clip_edge 的邊線另外取一個群組 nonedge。</p><h1 id="取出邊線"><a href="#取出邊線" class="headerlink" title="取出邊線"></a>取出邊線</h1><img src="/houdini-slice-curve/07.png"><p>然後用 polycut 把 nonedge 給去除掉，這樣就可以留下單純的 clip_edge，基本上到這步就結束了。</p><h1 id="清除殘餘"><a href="#清除殘餘" class="headerlink" title="清除殘餘"></a>清除殘餘</h1><p>不過如果你是對開放式模型作處理，就可能會像上圖紅箭頭處一樣，留下一些殘餘，接下來就要針對殘餘作清除。</p><img src="/houdini-slice-curve/08.png"><p>另外創一個比模型大的 grid ，並讓它繼承 clip 屬性來實體化切面。</p><p>繼承方法很簡單，grid 的 center 對應 clip 的 origin，然後 grid 下面接上一個 transform axis，transform axis 的 direction 跟 translate 分別對應 clip 的 direction 跟 distance。</p><h1 id="判斷清除"><a href="#判斷清除" class="headerlink" title="判斷清除"></a>判斷清除</h1><img src="/houdini-slice-curve/09.png"><p>接著讓每個 point 跟此 grid 的距離作一個判斷閥值，便可以輕鬆清除乾淨。</p><p>其實可以把整個節點樹做成一個簡單的 otl ，相信會很常用到。</p>]]></content>
    
    <summary type="html">
    
      &lt;video src=&quot;/houdini-slice-curve/cover.mp4&quot; autoplay loop&gt;&lt;/video&gt;
&lt;p&gt;上一篇的截線是針對球型的，那如果是任意模型的截面呢？&lt;/p&gt;
&lt;p&gt;或許會直覺想說，創造一個 grid，然後跟模型用 cookie 的方式選擇 crease 模式去取出來，但其實布林的方式限制很多(例如模型要封閉)，各種不穩定的因素，而且也比較需要計算效能。&lt;/p&gt;
&lt;p&gt;在這邊使用的是以 clip 為主軸的方法，效能快，穩定，而且模型也不需要封閉。&lt;br&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Houdini利用圓切面來做環繞球型的線</title>
    <link href="https://mur.elii.io/houdini-vex-sphere-center/"/>
    <id>https://mur.elii.io/houdini-vex-sphere-center/</id>
    <published>2016-09-04T10:08:41.000Z</published>
    <updated>2018-04-20T20:16:29.000Z</updated>
    
    <content type="html"><![CDATA[<video src="/houdini-vex-sphere-center/cover.mp4" autoplay loop></video><p>前陣子有一個需求效果，是要做許多環繞在球型上的切線。</p><p>在經過幾個測試評估後，決定在球心附近產生亂數點，給予方向屬性，然後找出通過此點並垂直球心的的圓切面來取得線段，可以達到最大的調整彈性跟計算效率。<br><a id="more"></a></p><h1 id="產生參考點"><a href="#產生參考點" class="headerlink" title="產生參考點"></a>產生參考點</h1><img src="/houdini-vex-sphere-center/01.png"><p>首先就是要產生每個切線的圓心，利用一顆要小許多的球來產生點，讓範圍只在球心附近徘徊，因為不想產生半徑太小的圓切面。</p><h1 id="設定參考點屬性"><a href="#設定參考點屬性" class="headerlink" title="設定參考點屬性"></a>設定參考點屬性</h1><img src="/houdini-vex-sphere-center/02.png"><p>接著幫每個點設定隨機的垂直 up 跟 N，去決定圓切面的方向。</p><h1 id="求出圓心"><a href="#求出圓心" class="headerlink" title="求出圓心"></a>求出圓心</h1><img src="/houdini-vex-sphere-center/03.png"><p>最重點的地方，利用數學公式去找出通過點並垂直球心的圓心。</p><p>整理後的公式如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span> <span class="title">getCircleCenter</span><span class="params">(<span class="built_in">vector</span> p_normal, p_pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a, b, c, x, y, z;</span><br><span class="line">    assign(a, b, c, p_normal);</span><br><span class="line">    assign(x, y, z, p_pos);</span><br><span class="line">    <span class="keyword">float</span> d = -a*x - b*y - c*z;</span><br><span class="line">    <span class="keyword">float</span> t = -( d / (a*a + b*b + c*c) ); </span><br><span class="line">    <span class="keyword">return</span> p_normal * t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p_normal = 點的N，p_pos = 點的位置，這是圓心為&#123;0, 0, 0&#125;下的簡易公式</span></span><br></pre></td></tr></table></figure></p><p>有圓心後再依據其方向投射到球面(外殼)的位置找到半徑數值寫在pscale裡面，並用copy circle的方式便可以產生環繞球型的切線。</p><h1 id="particle點綴"><a href="#particle點綴" class="headerlink" title="particle點綴"></a>particle點綴</h1><img src="/houdini-vex-sphere-center/04.png"><p>這邊是點綴效果，讓每個線上都有particle在跑，因為有up跟圓心的數值，可以用cross product輕鬆求出v值的方向做出這個效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;video src=&quot;/houdini-vex-sphere-center/cover.mp4&quot; autoplay loop&gt;&lt;/video&gt;
&lt;p&gt;前陣子有一個需求效果，是要做許多環繞在球型上的切線。&lt;/p&gt;
&lt;p&gt;在經過幾個測試評估後，決定在球心附近產生亂數點，給予方向屬性，然後找出通過此點並垂直球心的的圓切面來取得線段，可以達到最大的調整彈性跟計算效率。&lt;br&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
  </entry>
  
  <entry>
    <title>3ds max的VR全景VIEWPORT擷取工具(附帶影片生成)</title>
    <link href="https://mur.elii.io/max-vr-viewport-tool/"/>
    <id>https://mur.elii.io/max-vr-viewport-tool/</id>
    <published>2016-04-03T19:01:16.000Z</published>
    <updated>2018-04-20T18:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container"><iframe src="//player.vimeo.com/video/161382227" frameborder="0" allowfullscreen></iframe></div><p>最近公司開始越來越多 VR 的案子，看有些只是要確認動態的 previz，也必須用 Vray 算出來很浪費時間。最近了解到 windows 的 command line 的強大後，測試一下發現要寫出生成 VR viewport 影片其實不會太艱難，便著手進行。</p><p>由於對於 Maxscript 不是很深入，在這次寫工具的過程中遇到一些關卡，在這邊筆記下來。</p><a id="more"></a><hr><img src="/max-vr-viewport-tool/01.png"><p>最後完成的工具如上圖：</p><p>指定要擷取的攝影機，給予檔名路徑，選擇是否縮放尺寸，指定截圖品質，選擇是否要算成影片，影片品質，是否保留截圖序列，是否只擷取 Geometry，擷取的時間範圍。</p><p>Script 的整體流程是，創造六個攝影機綁在指定攝影機上，擷取六個方位截圖，產生 Cubemaps，再把 Cubemaps 轉換成 Equirectangular 形式，最後再算成影片檔。</p><hr><img src="/max-vr-viewport-tool/02.png"><p>遇到的第一個問題便是產生的 Cubemaps 怎麼轉換成 Equirectangular？</p><p>在經過多方資料參考後，按照這個網址的解答去製作了 maxscript 版本的算式。問題是，maxscript 的 bitmap 可撐不住這種算法，一般尺寸就會運算很久，所以果斷放棄。</p><p>後來不斷尋覓一些可以從 command line 執行的轉換程式，找到一個非常理想的程式叫做 krpanotools，裡面便含有一個cube2sphere的exe檔，去做輕便並快速的轉換。</p><p>而且這個程式是讀取六張單張個別的 Cubemap，所以我不用在 maxscript 先行合併起來，省去了一段 maxscript 運算緩慢的時間。</p><hr><img src="/max-vr-viewport-tool/03.png"><p>另外要把轉換出來的圖像序列，在編碼成 H.264 影片，畢竟這種 VR 全景的預覽，都是要丟給 GearVR 或者 Kolor 播放器，這邊便使用了已經封裝好的 ffmpeg去做處理，相當簡單方便。</p><p>剩下的就是去做 maxscript 跟 windows command line 的整合，並去隱藏或者命名一些檔案讓整個程序看起來簡化一些。</p><hr><img src="/max-vr-viewport-tool/04.png"><p>在流程方面的關卡都解決後，遇到擷取 viewport 畫面的問題，要怎麼去偵測使用者的 viewport 設定，並去關閉 viewport 上不必要的資訊，甚至取消背景的漸層，統一 viewport 的燈光，才能讓六張截圖完美融接。</p><p>程式碼有大半的行數都是花在這上面：擷取設定-&gt;覆蓋設定-&gt;(截圖)-&gt;還原設定。</p><p>尤其有一部份必須調用 DialogMonitorOPS 去做設定，這部分整理了很久才做出很簡潔的 Fuction 去處理。</p><p>如果有興趣的話，<a href="/max-vr-viewport-tool/eli_VRviewportCapture.ms" title="這邊是 Script 原始檔">這邊是 Script 原始檔</a>，可能還有很多 Bug，僅供參考。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//player.vimeo.com/video/161382227&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;最近公司開始越來越多 VR 的案子，看有些只是要確認動態的 previz，也必須用 Vray 算出來很浪費時間。最近了解到 windows 的 command line 的強大後，測試一下發現要寫出生成 VR viewport 影片其實不會太艱難，便著手進行。&lt;/p&gt;
&lt;p&gt;由於對於 Maxscript 不是很深入，在這次寫工具的過程中遇到一些關卡，在這邊筆記下來。&lt;/p&gt;
    
    </summary>
    
    
      <category term="3ds max" scheme="https://mur.elii.io/tags/3ds-max/"/>
    
      <category term="maxscript" scheme="https://mur.elii.io/tags/maxscript/"/>
    
      <category term="vr" scheme="https://mur.elii.io/tags/vr/"/>
    
  </entry>
  
  <entry>
    <title>Houdini製作程序性剝皮效果</title>
    <link href="https://mur.elii.io/houdini-peel-effect/"/>
    <id>https://mur.elii.io/houdini-peel-effect/</id>
    <published>2016-01-08T18:37:25.000Z</published>
    <updated>2018-04-20T18:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container"><iframe src="//player.vimeo.com/video/151223837" frameborder="0" allowfullscreen></iframe></div><p>前幾天看了一段 breakdown ，看到影片裡18秒處的效果覺得自己應該做得到，就趁工作閒餘試著做了出來，結果一個專案同事看到很喜歡想套到他的專案裡，問題是他想成形的是一個LOGO，而不是像那段影片只是一個簡單重複的圓形，完全不同邏輯的東西，不過這幾天還是硬著頭皮想出了一套製作方法。</p><p>下面簡單說明一下整個節點流程，效果就如上面影片，一切的目標方向是以未來還可以套別的模型，完全程序性來製作。<br><a id="more"></a></p><hr><img src="/houdini-peel-effect/01.png"><p>LOGO模型是同事用 3ds max 做的，因為模型最後上了 symmetry ，所以中間有一段 loop edge ，就直接抽出這段 edge ，來當產生點。</p><hr><img src="/houdini-peel-effect/02.png"><p>接著要找出每個產生點到末端的位置，末端的資訊很重要，影響之後所有的流程。</p><hr><img src="/houdini-peel-effect/03.png"><p>找到每個產生點的末端後，開始製作每個產生點沿著模型到末端的路徑，這邊是利用 cookie(crease) 的方式產生切線，以 產生點 -&gt; 末端 的向量來旋轉 cookie 的平面，得到切線後，再去判斷切線要留著的段落，讓最後只剩餘產生點到末端的curve。</p><hr><img src="/houdini-peel-effect/04.png"><p>從上面步驟取得每條導引線後，每條導引線會再複製一份，並取隔壁條導引線的 attribute 覆蓋，這是為了之後要拿兩兩一組導引線 skin 包面。</p><p>在這之前要先做導引線的動態，旋轉的方式是以每個點為基準來判斷，每個點的 normal 跟 up 加上總變數 時間點 的影響，依照從屬跟 ramp 的調節，設定出最後旋轉完的位置。</p><hr><img src="/houdini-peel-effect/05.png"><p>最後是包面，以兩兩一組的導引線做處理，由於導引線的 point 數不一定會一樣，要一樣的 point 數才能用 rails 包面，所以做了一個在不影響外觀的情況下讓兩條導引線補成相同 point 數的運算式。</p><p>包面完成後，最後的外觀樣子由於以上流程的種種因素，跟原本的模型一定會有非常細微的差距，這邊再以其中流程產生的豐富資訊，去判斷漸進貼齊原本模型的表面。</p><p>最後將其每個點的動態資訊寫在 UV 上，到時匯給 max 可以在模型上套一個 gradient map 貼圖去取得 UV 資訊，再以其作 matte 給 2D 做更多細節修正。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//player.vimeo.com/video/151223837&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;前幾天看了一段 breakdown ，看到影片裡18秒處的效果覺得自己應該做得到，就趁工作閒餘試著做了出來，結果一個專案同事看到很喜歡想套到他的專案裡，問題是他想成形的是一個LOGO，而不是像那段影片只是一個簡單重複的圓形，完全不同邏輯的東西，不過這幾天還是硬著頭皮想出了一套製作方法。&lt;/p&gt;
&lt;p&gt;下面簡單說明一下整個節點流程，效果就如上面影片，一切的目標方向是以未來還可以套別的模型，完全程序性來製作。&lt;br&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
  </entry>
  
  <entry>
    <title>在Houdini壓縮VDB和Volume的容量</title>
    <link href="https://mur.elii.io/houdini-vdb-volume-compress/"/>
    <id>https://mur.elii.io/houdini-vdb-volume-compress/</id>
    <published>2015-11-26T18:32:18.000Z</published>
    <updated>2018-04-20T18:36:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Pyro 的 resize container 有時候會讓快速物件的 velocity 一直碰壁，造成不好看的動態，在這種時候取消使用 resize container 卻會造成 cache 相當大，整個 cache 明明 density 佔很小一塊，卻保存了整個框架的 velocity，很沒必要。</p><p>在 houdini 15，有一個新 sop 可以很簡單解決這件事情，讓 velocity 資訊 clip 到只剩 density 周圍。</p><a id="more"></a><hr><img src="/houdini-vdb-volume-compress/01.png"><p>上面是一個從原始 cache 輸出 VDB 的壓縮流程，上半部是方才所提到的刪除方式，下半部只把 VDB 壓縮成 16-bit 。</p><hr><img src="/houdini-vdb-volume-compress/02.png"><p>首先先用 volume blur 取出比 density 大一點的範圍，等等要當作 mask。</p><hr><img src="/houdini-vdb-volume-compress/03.png"><p>接著使用 houdini 15 最新出的 volume compress 取剛剛的 mask 去刪除不必要的資訊。</p><hr><img src="/houdini-vdb-volume-compress/04.png"><p>轉成 VDB 後，上一個 primitive 去標記輸出時要存成 16-bit 的屬性。</p><p>上面的流程跑完，最後輸出的 VDB 甚至可以達到原本 cache 的十分之一大小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pyro 的 resize container 有時候會讓快速物件的 velocity 一直碰壁，造成不好看的動態，在這種時候取消使用 resize container 卻會造成 cache 相當大，整個 cache 明明 density 佔很小一塊，卻保存了整個框架的 velocity，很沒必要。&lt;/p&gt;
&lt;p&gt;在 houdini 15，有一個新 sop 可以很簡單解決這件事情，讓 velocity 資訊 clip 到只剩 density 周圍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="tip" scheme="https://mur.elii.io/tags/tip/"/>
    
      <category term="vdb" scheme="https://mur.elii.io/tags/vdb/"/>
    
      <category term="volume" scheme="https://mur.elii.io/tags/volume/"/>
    
  </entry>
  
  <entry>
    <title>Houdini大量Debris匯出給3ds Max、Maya的兩種效率方式</title>
    <link href="https://mur.elii.io/houdini-max-maya-transfer-cache/"/>
    <id>https://mur.elii.io/houdini-max-maya-transfer-cache/</id>
    <published>2015-11-25T18:19:14.000Z</published>
    <updated>2018-04-20T20:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<video src="/houdini-max-maya-transfer-cache/cover.mp4" autoplay loop></video><p>為了增加碎裂的細節通常會用particle模擬一層debris，再用簡單的幾何形狀去copy。不過如果後端算圖是要給Maya或Max，出alembic交接的話，會是非常龐大的資料量。</p><p>這邊介紹一下兩種研究出來的方法。</p><a id="more"></a><h1 id="方法A"><a href="#方法A" class="headerlink" title="方法A"></a>方法A</h1><p>第一種是只適合在max使用容量最小的方法，需要使用Frost。</p><hr><img src="/houdini-max-maya-transfer-cache/01.png"><p>先將particle匯出prt ，這邊是以國外強者維護編譯的ROP來執行，要把orient、pscale、id的attribute名稱對映到prt可讀的Orientation、Radius跟ID。</p><hr><img src="/houdini-max-maya-transfer-cache/02.png"><p>在max裡匯入prt，可以直接在frost裡讀particle檔案，但通常我會創一個prt loader去讀取以便再上magma修改。</p><p>只要有Radius跟Orientation通道，再把houdini的碎塊讀進來當custom geometry的source，就可以省下很多資料量達到跟houdini的copy一樣的效果。另外如果custom geometry不只一個，記得要勾選random id，不然採樣模型動起來會閃爍不固定。</p><h1 id="方法B"><a href="#方法B" class="headerlink" title="方法B"></a>方法B</h1><hr><img src="/houdini-max-maya-transfer-cache/03.png"><p>之前有介紹過一種快速輸出point cache的方法，這種方法等於我們只要存一格完整資訊的debris，再用只紀錄頂點位置的point cache去形變即可，容量也是不大。</p><p>但這邊有一個非常大的問題：<strong>point cache只能相容固定頂點數的模型</strong>。</p><p>像debris這種particle生成隨時間增加數量的物件，不可能每格一樣多，所以基本上不能使用這種方法。</p><p>不過，debris也有一種特性：一旦生成就不會消失，數量只會遞增。</p><p>所以我們可以取最後一格的particle當sample，這一格有所有其他格的particle，以id的屬性來跟前面格數一一比對，前面格數沒有的id，就全部生成補上去，然後保存下來，便可以達成全部格數一致，也不會被看見。</p><p>這種方法，用python比vex方便很多，所以在這邊就新增一個python sop。</p><hr><img src="/houdini-max-maya-transfer-cache/04.png"><p>用python的set很輕易地就可以取出每一格沒有的point補上去，因為這邊除了id要特別指定之外 ，大部分attribute預設就是0，scale也會是0不會被看見，就不用再另外指定數值。通過這個python sop，particle數量就一致了，接著處理要instance的碎片部分。</p><hr><img src="/houdini-max-maya-transfer-cache/05.png"><p>要將碎片複製成與particle一樣數量後，用transform pieces結合起來，如同packed rbd的模擬一樣。首先，碎片先自行經過一次copy，copy的資訊記得要帶上id給primitive，通常還會stamp這id去random每個碎片的旋轉，這邊值得注意的是這copy之前，<strong>採樣points的pscale要先全部設為1基準值</strong>，並採用最後一格的時間，待會的transform才會正確。複製完後，再把這兩者transform pieces藉由id結合起來，transform pieces的rest points輸入點一定要再接一次剛剛複製用的採樣points，到這邊就可以得到一個跟平常copy方法完全一模一樣位移旋轉的碎塊，卻有固定頂點數。接下來用之前的PC2出法再外加單格fbx，時間跟容量都節省相當多。</p><p>以上如果是要匯給max已經作業完成，但如果要給maya，還要把pc2轉換成maya的pointcache檔。</p><p>轉換方法很簡單，開啟maya的mel輸入以下指令即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cacheFile -pc2 1 -pcf “X:/path/debris.pc2” -dir “X:/output_path/” -format “OneFile” -f “cache_name”;</span><br></pre></td></tr></table></figure></p><hr><img src="/houdini-max-maya-transfer-cache/06.png"><p>260多萬面的debris，200格的動態，檔案大小只壓縮在3~4GB，而且在max和maya裡都還拖得動。</p>]]></content>
    
    <summary type="html">
    
      &lt;video src=&quot;/houdini-max-maya-transfer-cache/cover.mp4&quot; autoplay loop&gt;&lt;/video&gt;
&lt;p&gt;為了增加碎裂的細節通常會用particle模擬一層debris，再用簡單的幾何形狀去copy。不過如果後端算圖是要給Maya或Max，出alembic交接的話，會是非常龐大的資料量。&lt;/p&gt;
&lt;p&gt;這邊介紹一下兩種研究出來的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="3ds max" scheme="https://mur.elii.io/tags/3ds-max/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
      <category term="maya" scheme="https://mur.elii.io/tags/maya/"/>
    
      <category term="point cache" scheme="https://mur.elii.io/tags/point-cache/"/>
    
      <category term="python" scheme="https://mur.elii.io/tags/python/"/>
    
      <category term="frost" scheme="https://mur.elii.io/tags/frost/"/>
    
      <category term="mel" scheme="https://mur.elii.io/tags/mel/"/>
    
  </entry>
  
  <entry>
    <title>Vex在Attribute裡給予Array型態</title>
    <link href="https://mur.elii.io/houdini-vex-attribute-array/"/>
    <id>https://mur.elii.io/houdini-vex-attribute-array/</id>
    <published>2015-11-24T18:14:08.000Z</published>
    <updated>2018-04-19T18:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>例如要給予 int 陣列，打上 ：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i@sample[] = <span class="built_in">array</span>(int1, int2, int3);</span><br></pre></td></tr></table></figure></p><p>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;例如要給予 int 陣列，打上 ：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;i@sample[] = &lt;span class=&quot;built_in&quot;&gt;
      
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="tip" scheme="https://mur.elii.io/tags/tip/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
  </entry>
  
  <entry>
    <title>Houdini長條物體依方向縮放</title>
    <link href="https://mur.elii.io/houdini-transform-bounding/"/>
    <id>https://mur.elii.io/houdini-transform-bounding/</id>
    <published>2015-11-13T17:37:46.000Z</published>
    <updated>2018-04-20T20:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<video src="/houdini-transform-bounding/cover.mp4" autoplay loop></video><p>從前端那邊拿到模型基本上都是一個合併的完整模型，像上圖傳統建築的木頭梁柱，要每一根去縮放做Fracture產生木頭的碎裂形狀，卻是一整個模型沒有軸向。</p><p>遇到這樣的狀況其實使用Bound很容易解決。</p><a id="more"></a><hr><img src="/houdini-transform-bounding/01.png"><p>大概作法就是產生物體的oriented bounding box，取出bounding box的最長邊向量，並將向量代入transform axis去縮放。</p><hr><img src="/houdini-transform-bounding/02.png"><p>將物體分開處理後，產生Bounding box，勾選Oriented Bounding Box這神奇的功能，記得之前在max為了算出動態物件在FumeFX裡最佳化大小的外框有研究過這種東西，很複雜。</p><hr><img src="/houdini-transform-bounding/03.png"><p>在Bounding Box下，每一個point一定會連接三個不同邊長，取出來算出最長邊的向量保存起來。</p><hr><img src="/houdini-transform-bounding/04.png"><p>使用Transform Axis去取資訊，再調整Scale數值即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;video src=&quot;/houdini-transform-bounding/cover.mp4&quot; autoplay loop&gt;&lt;/video&gt;
&lt;p&gt;從前端那邊拿到模型基本上都是一個合併的完整模型，像上圖傳統建築的木頭梁柱，要每一根去縮放做Fracture產生木頭的碎裂形狀，卻是一整個模型沒有軸向。&lt;/p&gt;
&lt;p&gt;遇到這樣的狀況其實使用Bound很容易解決。&lt;/p&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="vex" scheme="https://mur.elii.io/tags/vex/"/>
    
      <category term="tutorial" scheme="https://mur.elii.io/tags/tutorial/"/>
    
  </entry>
  
  <entry>
    <title>houdini匯入FBX大量節點合併與材質整理</title>
    <link href="https://mur.elii.io/houdini-fbx-manage/"/>
    <id>https://mur.elii.io/houdini-fbx-manage/</id>
    <published>2015-11-10T16:29:45.000Z</published>
    <updated>2018-04-19T18:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近常處理max或maya的FBX丟進來的場景，通常匯進來的FBX要在另外建一個sop做合併彙整，但必須是一個node對一個object merge來針對各自物件做不同碎裂，如果FBX裏面物件很多，合併起來是相當麻煩的事情，所以這種重複的作業還是寫一個script去處理比較適當。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hou.ui.setStatusMessage(<span class="string">"Select source node"</span>, severity=hou.severityType.Message)</span><br><span class="line">source = hou.ui.selectNode()</span><br><span class="line"><span class="keyword">if</span> source != <span class="keyword">None</span> <span class="keyword">and</span> source != <span class="string">""</span>:</span><br><span class="line">    hou.ui.setStatusMessage(<span class="string">"Select target node"</span>, severity=hou.severityType.Message)</span><br><span class="line">    target = hou.ui.selectNode()</span><br><span class="line"><span class="keyword">if</span> source == <span class="keyword">None</span> <span class="keyword">or</span> source == <span class="string">""</span> <span class="keyword">or</span> target == <span class="keyword">None</span> <span class="keyword">or</span> target == <span class="string">""</span>:</span><br><span class="line">    hou.ui.displayMessage(<span class="string">"Invalid nodes"</span>, (<span class="string">"OK"</span>,), hou.severityType.Warning, title=<span class="string">"Warning"</span>)</span><br><span class="line"><span class="keyword">else</span>:   </span><br><span class="line">    s_node = hou.node(source)</span><br><span class="line">    t_node = hou.node(target)</span><br><span class="line">  </span><br><span class="line">    import_list = []</span><br><span class="line">    create_list = []</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> s_node.children():</span><br><span class="line">        <span class="keyword">if</span> child.type().name() == <span class="string">"geo"</span>:</span><br><span class="line">            import_list.append(child.name())</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> import_list:</span><br><span class="line">        m = t_node.createNode(<span class="string">"object_merge"</span>)</span><br><span class="line">        create_list.append(m)</span><br><span class="line">        m.parm(<span class="string">"objpath1"</span>).set(source + <span class="string">"/"</span> + node)</span><br><span class="line">        m.parm(<span class="string">"xformtype"</span>).set(<span class="number">1</span>)</span><br><span class="line">      </span><br><span class="line">    chk_merge = hou.ui.displayMessage(<span class="string">"Merge all node?"</span>, (<span class="string">"Yes"</span>, <span class="string">"No"</span>), hou.severityType.Message, title=<span class="string">"Warning"</span>)</span><br><span class="line">    <span class="keyword">if</span> chk_merge == <span class="number">0</span>:</span><br><span class="line">        merge = t_node.createNode(<span class="string">"merge"</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> create_list:</span><br><span class="line">            merge.setNextInput(node)</span><br><span class="line">          </span><br><span class="line">    t_node.layoutChildren()</span><br></pre></td></tr></table></figure></p><hr><p>另外，FBX匯進來的物件，其物件材質會有兩種情況：如果是單一材質，材質會上在SOP上，如果是多重(multi-ID)材質，他會在SOP裡新增group跟material節點。假如一個FBX包含以上兩種，之後把整個FBX的物件合併，會發現前者的材質沒辦法帶到，因為該物件primitive的shop_materialpath屬性沒有東西，所以必須要針對該物件去寫上屬性，這種事情也是很常發現，故也寫了一個script。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hou.ui.setStatusMessage(<span class="string">"Select FBX subnetwork"</span>, severity=hou.severityType.Message)</span><br><span class="line">selectNode = hou.ui.selectNode()</span><br><span class="line"><span class="keyword">if</span> selectNode == <span class="keyword">None</span> <span class="keyword">or</span> selectNode == <span class="string">""</span>:</span><br><span class="line">    hou.ui.displayMessage(<span class="string">"Invalid node"</span>, (<span class="string">"OK"</span>,), hou.severityType.Warning, title=<span class="string">"Warning"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    chk_clean = hou.ui.displayMessage(<span class="string">"Clean material path?"</span>, (<span class="string">"Yes"</span>, <span class="string">"No"</span>), hou.severityType.Message, title=<span class="string">"Warning"</span>)</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> selectNode.children():</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> node.type().name() == <span class="string">"geo"</span>:</span><br><span class="line">            mpath = node.parm(<span class="string">"shop_materialpath"</span>)</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> mpath.eval() != <span class="string">""</span>:</span><br><span class="line">              </span><br><span class="line">                mat = node.path().replace(node.name(), mpath.eval()[<span class="number">3</span>:])</span><br><span class="line">              </span><br><span class="line">                geo_node = <span class="keyword">None</span></span><br><span class="line">                <span class="keyword">for</span> child <span class="keyword">in</span> node.children():</span><br><span class="line">                    <span class="keyword">if</span> child.isRenderFlagSet():</span><br><span class="line">                        geo_node = child</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line">                mat_node = node.createNode(<span class="string">"material"</span>)</span><br><span class="line">                mat_node.parm(<span class="string">"shop_materialpath1"</span>).set(mat)</span><br><span class="line">                mat_node.setNextInput(geo_node)</span><br><span class="line">                mat_node.setRenderFlag(<span class="keyword">True</span>)</span><br><span class="line">                mat_node.setDisplayFlag(<span class="keyword">True</span>)</span><br><span class="line">                <span class="keyword">if</span> chk_clean == <span class="number">0</span>:</span><br><span class="line">                    mpath.set(<span class="string">""</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近常處理max或maya的FBX丟進來的場景，通常匯進來的FBX要在另外建一個sop做合併彙整，但必須是一個node對一個object merge來針對各自物件做不同碎裂，如果FBX裏面物件很多，合併起來是相當麻煩的事情，所以這種重複的作業還是寫一個script去處理比較適當。&lt;br&gt;
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="tip" scheme="https://mur.elii.io/tags/tip/"/>
    
      <category term="fbx" scheme="https://mur.elii.io/tags/fbx/"/>
    
      <category term="python" scheme="https://mur.elii.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Houdini純帶頂點動態物件輸出給3ds Max的效率方式</title>
    <link href="https://mur.elii.io/houdini-3dsmax-pointcache/"/>
    <id>https://mur.elii.io/houdini-3dsmax-pointcache/</id>
    <published>2015-10-01T16:14:32.000Z</published>
    <updated>2018-04-20T20:17:03.000Z</updated>
    
    <content type="html"><![CDATA[<video src="/houdini-3dsmax-pointcache/cover.mp4" autoplay loop></video><p>最近案子遇到要將max的建築物在houdini碎完做好動態再輸出回去，整個流程有幾個需要注意的點是：</p><ul><li>建築物本身自帶多種材質，也就是在max裡有上多個material ID</li><li>物件只有進行碎裂跟位移，面數、頂點數跟其他屬性都是固定無動態<a id="more"></a>基於第一點，要在max-&gt;houdini-&gt;max的流程下保持材質，FBX可以說是最方便的格式之一，連材質名稱都可以保留(對應primitive的shop_materialpath)，要對回去很方便。</li></ul><p>而第二點可以判定說，我們只要一個有完整資訊的物件，再讓houdini輸出point cache去移動頂點可以做到最有效率跟節省空間的方法。</p><p>houdini在原先選單輸出帶point cache的FBX會有許多問題，normal有時會跑掉，而且point cache的容量跟輸出速度都異常的大跟久，甚至在max匯入會有後續影格讀不到的問題，完全沒有point cache該有的優勢。</p><p>後來解決的方法是利用原先FBX輸出單一無動態物件，再另外以script輸出給max吃純帶位置資訊的point cache，PC2檔案。</p><p>本來還想說研究PC2的格式自己去寫，沒想到已經有大神研究好了，<a href="https://forums.odforce.net/topic/19535-inline-cpp-pc2-exporter/" target="_blank" rel="noopener">如果有興趣可以參閱這篇文章</a>。</p><p>在這邊直接引用 <strong>glassman3d</strong> 大的script：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doCache</span><span class="params">()</span>:</span></span><br><span class="line">    sf = hou.evalParm(<span class="string">"startframe"</span>)</span><br><span class="line">    ef = hou.evalParm(<span class="string">"endframe"</span>)</span><br><span class="line">    sr = <span class="number">1</span></span><br><span class="line">    ns = (ef - sf) + <span class="number">1</span></span><br><span class="line">    geo = hou.pwd().geometry()</span><br><span class="line">    points = geo.points()</span><br><span class="line">    np = len(points)</span><br><span class="line">    </span><br><span class="line">    pc2File = open(hou.evalParm(<span class="string">"file"</span>), <span class="string">"wb"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> hou.InterruptableOperation(<span class="string">"PC2 Cache"</span>,open_interrupt_dialog=<span class="keyword">True</span>) <span class="keyword">as</span> operation:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> hou.InterruptableOperation(<span class="string">"Exporting %s"</span> % hou.pwd().name(),open_interrupt_dialog=<span class="keyword">True</span>) <span class="keyword">as</span> export:</span><br><span class="line">    </span><br><span class="line">            <span class="comment"># Write header</span></span><br><span class="line">            headerFormat=<span class="string">'&lt;12siiffi'</span></span><br><span class="line">            <span class="comment">#headerStr = struct.pack(headerFormat, 'P','O','I','N','T','C','A','C','H','E','2','\0', 1, np, sf, sr, ns)</span></span><br><span class="line">            headerStr = struct.pack(headerFormat, <span class="string">"POINTCACHE2\0"</span>, <span class="number">1</span>, np, sf, sr, ns)</span><br><span class="line">            pc2File.write(headerStr)</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> range(sf, sf+ns, sr):</span><br><span class="line">                hou.setFrame(f)</span><br><span class="line">                pos = geo.pointFloatAttribValuesAsString(<span class="string">"P"</span>)</span><br><span class="line">                pc2File.write(pos)</span><br><span class="line">                export.updateProgress( f/ns )</span><br><span class="line">                operation.updateLongProgress(<span class="number">0.5</span> * (f/ns) )</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">with</span> hou.InterruptableOperation(<span class="string">"Finishing"</span>,open_interrupt_dialog=<span class="keyword">True</span>) <span class="keyword">as</span> finish: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            pc2File.flush()</span><br><span class="line">            pc2File.close()</span><br><span class="line">            finish.updateProgress(<span class="number">1</span>)</span><br><span class="line">            operation.updateLongProgress(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;video src=&quot;/houdini-3dsmax-pointcache/cover.mp4&quot; autoplay loop&gt;&lt;/video&gt;
&lt;p&gt;最近案子遇到要將max的建築物在houdini碎完做好動態再輸出回去，整個流程有幾個需要注意的點是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建築物本身自帶多種材質，也就是在max裡有上多個material ID&lt;/li&gt;
&lt;li&gt;物件只有進行碎裂跟位移，面數、頂點數跟其他屬性都是固定無動態
    
    </summary>
    
    
      <category term="houdini" scheme="https://mur.elii.io/tags/houdini/"/>
    
      <category term="tip" scheme="https://mur.elii.io/tags/tip/"/>
    
      <category term="3ds max" scheme="https://mur.elii.io/tags/3ds-max/"/>
    
      <category term="point cache" scheme="https://mur.elii.io/tags/point-cache/"/>
    
      <category term="python" scheme="https://mur.elii.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Maxscript寫俄羅斯方塊</title>
    <link href="https://mur.elii.io/maxscript-tetris/"/>
    <id>https://mur.elii.io/maxscript-tetris/</id>
    <published>2015-01-31T16:03:16.000Z</published>
    <updated>2018-04-19T16:32:13.000Z</updated>
    
    <content type="html"><![CDATA[<div class="video-container"><iframe src="//player.vimeo.com/video/118334814" frameborder="0" allowfullscreen></iframe></div><p>上禮拜為了一個海水模擬的案子需要批次修改模擬框架的參數，想說其實自己這樣houdini、UE4摸下來，也有點程式的概念，就來試著學學看用maxscript來做這些繁複無聊的手工調整。<br><a id="more"></a><br>稍微看了一下maxscript的手冊發現意外的好入門，可以很輕鬆地為自己的習慣或需求去做簡單的客製化工具。</p><p>在寫出模擬的小工具後就進一步想去寫更多的東西，一種開了一扇新的大門躍躍欲試的感覺。後來摸索maxscript的timer tick時，發現可以拿來寫遊戲，就萌生出寫個俄羅斯方塊當練習的想法。</p><p>一開始覺得不難，就方塊往下墜嘛。結果實際動手發現有很多細微的眉眉角角要注意(當然不能使用3D碰撞偵測這些作弊的方法)，方塊的旋轉方式、偵測的問題，本來只是打算當一個晚上的作業結果寫了三、四天，不過總算是告一段落。</p><a href="/maxscript-tetris/gameTetris.ms" title="script檔案">script檔案</a>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;video-container&quot;&gt;&lt;iframe src=&quot;//player.vimeo.com/video/118334814&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;上禮拜為了一個海水模擬的案子需要批次修改模擬框架的參數，想說其實自己這樣houdini、UE4摸下來，也有點程式的概念，就來試著學學看用maxscript來做這些繁複無聊的手工調整。&lt;br&gt;
    
    </summary>
    
    
      <category term="3ds max" scheme="https://mur.elii.io/tags/3ds-max/"/>
    
      <category term="maxscript" scheme="https://mur.elii.io/tags/maxscript/"/>
    
  </entry>
  
</feed>
